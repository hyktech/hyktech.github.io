<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【面向对象特征系列之“多态”】]]></title>
    <url>%2F2017%2F09%2F01%2F%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[面向对象特征当中最让初学者头疼的就算是“多态”了🤦‍♂️。“封装”、“继承”的概念大家在生活中还多多少少接触过，还能够做一定层度上的类推，但“多态”这个非生活用词就显得比较陌生了。“多态”的用途和表现形式又非常多，总是在程序设计与开发中出现，弄得的大家不知所措。这儿也是多态，那儿也是多态，那么多态到底是个啥呢？😭 什么是多态多态的概念：多态（Polymorphism）这个概念最早来自于生物学，表示的是同一物种在同一种群中存在两种或多种明显不同的表型。比如：在南美种群中存在两种颜色的美洲虎：浅黄色的和黑色的。而在面向对象编程思想中，这个概念表达的是具有共性的类型，在执行相同的行为时，会体现出不同的实现方式。我们可以简称为：相同的行为，不同的实现。 比如：同样看到对面过来一个美女，男人和女人的想法是不一样的。 多态在面向对象中的地位一说到面向对象特征，大家都能马上想到“封装”、“继承”、“多态”。1、“封装”是面向对象的基础，它让我们能够把现实环境的复杂内容进行归类，让编程无论在理解度上还是在语法上进行更好的表达；2、“继承”表达的是“重复”，是复用性的体现，能够让我们通过找到类型的共性进行更进一步的提取和划分；3、那么，“多态”则是多样性、可扩展性的体现。面对丰富的和可能不断变化的问题域，让我们的程序能够有更大的容纳性去模拟和适应这些变化。它表达的是“变化”，这就是为什么“多态”能够跻身面向对象三大特征的原因！ 注意：由于“多态”的概念是---相同的行为，不同的实现；所以，对我们而言只有方法才有“多态”性的体现，这点别搞错了～～～ 多态的分类多态分为两种形式：静态多态和动态多态。这里的静态与关键字static并没有什么关系。动静之分主要是表现在程序是在运行期还是编译期，通过被绑定的对象类型来决定到底执行的是哪个方法。静态多态是在编译期就确定了对象以及对象行为的绑定关系，所以运行起来以后就固定为编译期确定的效果；而动态多态是在编译期未知绑定关系，运行进行以后才进行绑定，所以具有更大的灵活性；很明显，动态多态具有更大的灵活性和可扩展性，所以它才是我们使用率更高的多态方式，也是这篇博客要讲述的重点。 静态多态诚如上面所言，静态多态是在编译期间就可以确定要执行的是何种类型的对象以及该对象的何种行为，运行期不会有改变的情况。所以 方法重载 或 单独使用方法重写 都是它的具体表现形式。 方法的重载 方法重载：在一个类当中，具有多个同名方法，参数列表不同（包括：参数个数、参数类型、参数顺序的不同），从而各有各的实现。 123456789101112131415161718public class Student&#123; public void study()&#123; System.out.println("自习"); &#125; public void study(String subject)&#123; System.out.println("完成当天课程：" + subject + "的课后作业。"); &#125;&#125;public class Teacher&#123; private Student stu; public void teach()&#123; System.out.println("现在布置任务："); //stu.study(); stu.study("数学"); &#125;&#125; 讲解：1、Student(学生)类当中拥有两个同名方法study(学习)，一个无参、一个带参，这是标准的重载语法。2、两个study方法之所以同名，是因为它们都是学生类的“学习”行为，但各有各的实现，所以这符合“相同的行为，不同的实现”，这是一个“多态”的设计。3、Teacher(老师)类中绑定了一个Student对象stu，在它的teach方法中调用了stu对象的study行为；如果调用代码是不传参的，那么运行效果一定是“自习”的效果；如果传的是字符串参数，那么运行效果一定是“完成课后作业”的效果。在这里体现了：运行的最终效果，其实在编译Teacher类的时候就被确定了。要想改变运行效果，那么只有改写teach方法中的调用代码。这就是所谓的“静态多态”。 方法的重写 方法重写：在继承关系中，不同的子类都拥有继承于父类的某个共有方法，但是各有各的实现。 12345678910111213141516171819202122232425public abstract class Gun&#123; public abstract void fire();&#125;public class Rifle extends Gun&#123; public void fire()&#123; System.out.println("砰～～～"); &#125;&#125;public class MachineGun extends Gun&#123; public void fire()&#123; System.out.println("哒哒哒哒哒"); &#125;&#125;public class Soldier&#123; //private Rifle gun;//绑定步枪对象 private MachineGun gun;//绑定机枪对象 public void fight()&#123; System.out.println("射击！"); this.gun.fire(); &#125;&#125; 讲解：1、Gun(枪)类有一个方法叫做fire(开火)。Rifle(步枪)和MachineGun(机枪)都是Gun的子类，各自重新实现自己fire方法的特殊实现。这是标准的重写语法。2、步枪，机枪都是枪，都拥有开火行为，但各有各的实现，所以这符合“相同的行为，不同的实现”，这是一个“多态”的设计。3、Soldier(士兵)类中绑定了一个MachineGun对象gun，在它的fight方法中调用了该对象的fire方法。这时运行fight方法的效果一定是机枪的“哒哒哒哒”效果；如果要换成步枪的效果，那么只有把绑定的gun对象类型从MachineGun换成Rifle。在这里同样体现了：运行的最终效果，其实在编译Soldier类的时候就被确定了。要想改变运行效果，那么只有改写gun对象的类型声明代码。这也是“静态多态”。 动态多态相对于静态多态，动态多态是什么效果呢？闲话少叙，先让我们看看代码： 123456789101112131415161718192021222324public abstract class Gun&#123; public abstract void fire();&#125;public class Rifle extends Gun&#123; public void fire()&#123; System.out.println("砰～～～"); &#125;&#125;public class MachineGun extends Gun&#123; public void fire()&#123; System.out.println("哒哒哒哒哒"); &#125;&#125;public class Soldier&#123; private Gun gun;//绑定枪对象 public void fight()&#123; System.out.println("射击！"); this.gun.fire(); &#125;&#125; 大家很容易就发现，这个动态多态的例子其实就是改动了一下上面静态多态中的第二个例子。差异在哪儿呢？为什么这个就“动态”了，之前那个就“静态”了呢？其实差异就只有这一句代码而已： 1private Gun gun; 在这个动态绑定的例子当中，Soldier（士兵）类中绑定的不再是某一个Gun（枪）的子类对象，而是父类Gun（枪）的对象。也许有同学会瞪大眼睛疑问：“Gun不是抽象类吗？不能产生对象呀？”其实，Gun是不是抽象类根本无所谓。因为在这里，我们压根儿也没有想过要让gun指向一个Gun对象，我们需要的就是它既可以指向Rifle（步枪）对象，也可以指向MachineGun（机枪）对象。无论以后运行起来绑定谁，都不需要修改Soldier（士兵）的代码！就算将来还有可能增加其它的枪（手枪，狙击枪，火药枪），只要它是枪，我们的Soldier中已有的绑定代码就可以直接使用，不用修改！！ 父类的引用指向子类的对象是的，只要它是枪！在这里，我们描述了在继承关系（is a）中出现的场景。在Java中除了本类的引用指向本类的对象，还可以让父类的引用指向子类的对象。 12Gun g1 = new Rifle();//正确Gun g2 = new MachineGun);//正确 场景上，“枪“当然可以是一把步枪，也可以是一挺机枪。“枪”类型可以指代任何一种枪对象，这与“步枪”类型只能指代步枪对象，“机枪”类型只能指代机枪对象是不同的。当然前提条件是要有继承关系，这个很生活吧😊。内存中，由于Java的对象内存模型采用的是“内存叠加的方式”，即：在子类对象产生的时候，会先调用父类的构造方法产生一个父类对象部分，然后再调用子类自己的构造方法，在该父类对象部分下面叠加上子类特有部分，从而形成一个完整的子类对象！所以，我们可以认为每一个子类对象中都包含了一个完整的父类对象部分。所以，当用父类引用指向这个子类对象的时候，JVM会发现这个对象确实有父类对象所有的内容，在编译上是没有问题的。所以，当我们绑定一个父类引用的时候，它既有可能指向父类的对象，也有可能是指向该父类的某个子类的对象。它是可变的，具体指向谁不是由编码期的声明决定的，而是可以通过在运行时传入不同的对象，从而形成所谓的“动态绑定”。 动态绑定与重写当父类引用指向子类对象以后，在使用这个引用调用方法的时候会发生什么呢？其实无非就三种情况 使用父类引用调用父类定义的方法； 使用父类引用调用子类定义的方法； 使用父类引用调用父类定义，但被子类重写了的方法。 第一种情况：其本质就是本类的引用调用本类的方法，所以也就没有任何编译或运行的问题；在知识点上，你只需要通过上面的图例3认清楚一点，子类对象中包含有来自于父类对象部分，那么理解起来就很简单了！ 第二种情况：你在调用的时候会发现根本调用不到，编译就会马上报错。其道理也很简单：虽然对象是子类对象，其中当然包含有子类自己定义的内容，但是由于我们的引用是父类类型（即我们是站在父类的层面去看待它），当然就看不到这些子类定义的内容了。如果想访问，那么必须进行“向下转型”。参看：向上转型，向下转型，还在头疼？ 第三种情况：这是我们在本博中所需要的“动态多态”的知识点。由于这个方法是重写方法，首先说明它的定义就是在父类当中，所以利用父类的引用当然可以看到有这个方法，保证能够使用引用调用得到；其次该方法被子类对象重写了，而且不同的子类可以各有各的实现，那么具体的运行效果，就要依赖于这个父类引用运行起来以后，到底是指向哪种子类的对象了（指向谁，就执行谁的重写后效果）。完整代码如下： 123456789101112131415161718192021222324252627282930313233343536public abstract class Gun&#123; public abstract void fire();&#125;public class Rifle extends Gun&#123; public void fire()&#123; System.out.println("砰～～～"); &#125;&#125;public class MachineGun extends Gun&#123; public void fire()&#123; System.out.println("哒哒哒哒哒"); &#125;&#125;public class Soldier&#123; private Gun gun;//绑定枪对象 public void fight()&#123; System.out.println("射击！"); this.gun.fire(); &#125; //省略get/set方法，请自行添加&#125;public class TestMain&#123; public static void main(String[] args)&#123; Soldier rambo = new Soldier(); rambo.setGun(new Rifle()); //rambo.setGun(new MachineGun()); rambo.fight(); &#125;&#125; 通过测试这个代码，我们可以看到，如果给rambo（兰博）对象传入Rifle（步枪）对象，那么他战斗的时候就是步枪的效果；如果传入MachineGun（机枪）对象，那么rambo（兰博）对象战斗就是机枪的效果。换步枪、换机枪，但是Soldier和Gun的绑定代码不变，就算以后有别的子类枪，Soldier的代码也无需修改，这就是我们需要的“动态多态”效果。 总结首先，我们来总结一下知识点：这里，我就不再写出答案了，请各位阅读者自行归纳描述。如果有需要，可以再返回到上面仔细阅读。 多态的概念是什么？ 什么是静态多态？什么是动态多态？ 动态多态是依赖什么技术实现的？ 动态多态的好处是什么？ 其次，以后我们可以扩展到哪些知识点： 接口的引用也可以指向实现类的对象； 反射实现动态产生对象； Spring完成IOC注入； 桥梁模式、装饰器模式、策略模式等常见设计模式； 聚合组合原则、依赖倒转原则等常见设计原则。]]></content>
      <categories>
        <category>JavaSE</category>
        <category>Java面向对象思想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【面向对象特征系列之“继承”】]]></title>
    <url>%2F2017%2F08%2F24%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[在上一篇系列文章中，我们聊过了面向对象的“封装”特征。在有了封装的基础上，今天我们在来谈谈面向对象第二个特征—-“继承”。👨‍🏫“继承”这个知识点在同学们学习的过程中，其实并不算是一个难点。在语法上，Java也把它设计得非常简单，一个extends关键字就可以搞定；在理解上，“继承”这个词在生活中也很常见，不存在什么晦涩难懂的地方。但一旦涉及到具体使用的时候，就会发现很多同学其实对它的认知度还是不高的。不然在面试中也就不会有这么多的关于“继承”的面试题目了。诸如🤷‍♀️：“Java单继承的优缺点是什么？”、“抽象类与接口到底有区别？”、“什么时候用继承？什么时候用组合？”……等等。所以，这次我们借用这篇文章把“继承”这个概念再梳理一下。💪 继承的由来听过我课的同学应该知道，我时常在课堂上强调一个观点：“复用与分离”。我认为在软件开发中很多新设计理念、新的语法、新的框架都是基于这个观点被推广、设计、应用的。“继承”同样也是如此。比如在一个宠物医院的管理系统中，会有很多不同类型的宠物（🐱、🐶、🐢、🐦）。它们都有各自的属性和行为，所以我们需要定义不同的类来表示它们。比如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class DogBean&#123; private String name; private int age; private int boneNum; //每天吃的骨头数目 private ArrayList&lt;DogBean&gt; children; //所生小狗的集合 public void play()&#123; //玩耍 &#125; public void swim()&#123; //游泳 &#125;&#125;public class CatBean&#123; private String name; private int age; private int fishNum; //每天吃的鱼数目 private ArrayList&lt;CatBean&gt; children; //所生小猫的集合 public void play()&#123; //玩耍 &#125; public void climbTree()&#123; //爬树 &#125;&#125;public class TortoiseBean&#123; private String name; private int age; public void play()&#123; //玩耍 &#125; public void sleep()&#123; //冬眠 &#125;&#125; public class BirdBean&#123; private String name; private int age; private int wormNum； //每天吃的虫数量 public void play()&#123; //玩耍 &#125; public void sing()&#123; //鸣叫 &#125;&#125; 写完以后，我们会觉得亏得慌。因为，在这些不同的类身上有些属性/行为是相同的，而我们却不得不在每个类里面都把这些相同的属性/行为重复书写一次。这时候咋办？当然就想到“继承”啦，就是这么自然！😊提出父类—宠物类，把共有的属性/行为写在它身上，各个子类通过“继承”机制，自动获得该父类的属性/行为，这不是“复用”是什么？面向对象的设计者也是这么想的😎，所以他们在面向对象语言中设计了继承的语法。光因为复用吗？其实“继承”也带来了分离的效果！在有了继承的情况下，在设计父类时我们只需要考虑共有的信息，设计子类时我们也只需要把精力放在该子类特有的信息上。这相当于把问题分解成了两个层面—共有和特有，各有所属分别设计和实现，不会出现混为一谈的情况。 12345678910111213141516171819202122232425262728293031323334353637383940public class PetBean&#123; private String name; private int age; public void play()&#123; //玩耍 &#125; &#125;public class DogBean extends PetBean&#123; private int boneNum; //每天吃的骨头数目 private DogBean[] children; //所生小狗的集合 public void swim()&#123; //游泳 &#125;&#125;public class CatBean extends PetBean&#123; private int fishNum; //每天吃的鱼数目 private CatBean[] children; //所生小猫的集合 public void climbTree()&#123; //爬树 &#125;&#125;public class TortoiseBean extends PetBean&#123; public void sleep()&#123; //冬眠 &#125;&#125; public class BirdBean extends PetBean&#123; private int wormNum； //每天吃的虫数量 public void sing()&#123; //鸣叫 &#125;&#125; 简单的看看上下两段代码的行数，你也能知道“继承”好不好了。 继承使用的原则从上面的示例，我们看到“继承”简直就是又简单又好用👍。由此也就造成了很多初学者的一个问题，那就是滥用继承。比如：A类里面有一个方法methodA()，B类想在自己的methodB()方法中调用这个来自于A类的方法，咋办呢？很多人下意识的就说让B继承A就可以了。 123456789101112131415public class A&#123; public void methodA()&#123; //methodA的实现 &#125;&#125;/* * 由于B类继承了A类，所以B类也就自动继承了methodA()。 * 所以可以直接在B类里面调用到该方法了。 */public class B extends A&#123; public void methodB()&#123; this.methodA(); &#125;&#125; 如果你这么用继承，那就大错特错了！因为你只站在了代码实现的级别，而没有考虑场景！如果要说实现这个功能，那么我们其实除了上面这个语法还有其他两种方式呢。 方式一： 12345678910111213141516public class A&#123; public void methodA()&#123; //methodA的实现 &#125;&#125;/* * B类包含一个A类的对象，作为B类的属性， * 然后调用该属性的methodA()方法。 */public class B&#123; private A myA = new A(); public void methodB()&#123; myA.methodA(); &#125;&#125; 方式二： 123456789101112131415public class A&#123; public void methodA()&#123; //methodA的实现 &#125;&#125;/* * B类的methodB()方法接收外部传入的A类对象参数， * 然后进行调用该参数的methodA()方法。 */public class B&#123; public void methodB(A myA)&#123; myA.methodA(); &#125;&#125; 可以看到，以上三种设计都可以让B类的methodB()方法操作到A类的methodA()方法。那么到底哪一种好呢？这其实就是我们在授课过程中常常跟同学们强调的一个东西了：场景。 场景的重要性： 写代码，绝对不是仅仅只为了实现某个功能。功能的实现只是最基本的目标，而在程序中正确的模拟现实问题域也是绝对不能忽视的问题。模拟的好与差决定了这个程序的生命力，决定了这个程序能否随着实际问题域的发展而发展。好的设计，能够在问题域自然变化的情况下，只经过简单改变就能继续使用；而差的设计很有可能就要面临大量的修改，甚至是推翻重来。 上面三种方式都能让B类与A类发生绑定关系，但其实它们代表的是面向对象中类与类之间的三种关系：继承、组合、使用，也就是我们常常说的”is-a“、”has-a“、”use-a“关系。在场景中，正确的判断两个类到底是什么关系，从而采用正确的设计（选择对应的语法），这才是王道，否则很有可能被现实打个响亮的耳光！ 举个例子：有两个类，一个Boy（男孩），一个Girl（女孩）。Boy类有一个kiss方法😚，Girl类有一个叫response（回应）的方法。当Boy的kiss方法在执行的最后，要调用Girl的response方法。我们用三种方式都能实现这个效果，但是他们描述的场景却截然不同。第一种：继承---“is-a”---是一个123456789101112public class Girl&#123; public void response()&#123; System.out.println("讨厌，你好坏......"); &#125;&#125;public class Boy extends Girl&#123; public void kiss()&#123; System.out.println("让我亲一个嘛～～～"); this.response(); &#125;&#125;Boy类继承了Girl类，这本身就说不通了吧……😓 又不是儿子和母亲的关系……还要接吻……🤢。算了，不说了🤐️。所以，这个场景千万不能设计成这种继承，否则你就是个BT！！！第二种：组合---“has-a”---有一个1234567891011121314public class Girl&#123; public void response()&#123; System.out.println("讨厌，你好坏......"); &#125;&#125;public class Boy extends Girl&#123; private Girl myGirl； public void kiss()&#123; System.out.println("让我亲一个嘛～～～"); myGirl.response(); &#125;&#125;Boy类拥有一个Girl类对象作为自己的属性。这就非常合情合理了，难道你的女朋友不是你生命中的一部分吗❤️？而且，由于Boy对象拥有了Girl对象，所以在Boy对象的任何行为中都可以操作到这个女友对象，让她参与到你生活的方方面面。这个场景就应该使用这样的设计。第三种：使用---“use-a”---用一个123456789101112public class Girl&#123; public void response()&#123; System.out.println("讨厌，你好坏......"); &#125;&#125;public class Boy extends Girl&#123; public void kiss(Girl myGirl)&#123; System.out.println("让我亲一个嘛～～～"); myGirl.response(); &#125;&#125;Boy类的kiss方法接收了一个外部参数是Girl的对象，由于参数只是一个局部变量，所以kiss方法结束后，这个Girl对象也就和Boy没有关系了。这个场景嘛……我觉得应该是描述了一种违反道德观的现象。两个对象只在亲吻的时候才有关联，亲吻结束后就互不相识了。还好是亲吻，如果是其它行为我觉得有必要打举报电话了。警察👮叔叔，有人卖哔～～～。通过以上分析，要向大家传递的一个内容就是：继承不是你想用就用的，请一定要在场景中分析出这些类真正的具备“is-a”关系。 Java的继承机制上面👆，我们描述的是面向对象编程思想中“继承”的概念。但是具体到面向对象的编程语言，不同的语言为了实现这个“继承”的效果，都提供的有自己的机制。作为Java语言的学习者，我们当然要掌握Java语言的继承机制啰。这里面包括了：单继承、内存叠加、接口和抽象类等等内容。由于这些东西内容比较多，又自成体系，所以我决定以后单开博客来讲述，然后再把链接放到这里来。 总结最后，当你以后被问到“你如何理解面向对象的继承”时，请做如下回答： 继承：是面向对象中的一种类与类之间的关系。当多个类具备一脉相承的“is-a”关系的时候，使用继承。这就能够让这些类进行正确的关联绑定，子类自动具备来自于的父类的属性和行为，做到代码的复用和设计的分离。]]></content>
      <categories>
        <category>JavaSE</category>
        <category>Java面向对象思想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【面向对象特征系列之“封装”】]]></title>
    <url>%2F2017%2F08%2F16%2F%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[搞编程的人，只要提到面向对象（OO），肯定就会想到面向对象的三大特征。”封装、继承、多态“几乎成了面试中必须要提到的问题，连朗沃的小卖部大妈都知道这三个东东了😊。可是知道是一回事情，但真要让我们把这三个东西说的清清楚楚、明明白白就又是另一回事情了😖。因为这三个概念实在是太抽象了😡，既涉及到编程语法，又上升到设计思想；既好像在代码中随处可见，又似乎隐藏在设计的思维中；让人好不头疼！所以，本博准备开一个专题，来聊聊这让人又爱又恨的“三大特征”。今天，我们就先来看看第一个特征“封装”。 前言“封装、继承、多态”，我们念成了口头禅，这个顺序还真不是可以随便改的。“封装”是整个面向对象的基础，没有封装性的话，后面两个特性也就白搭。对，封装就是这么🐂13！但是，很多人只要一提到封装就想到信息隐藏，一提到信息隐藏脑子里就只有一个private修饰符了，这也实在是太片面化和简单化了。那么， 什么是封装作为普通人，一想到“封装”这个词，脑子里面浮现的是什么？没错！就是这样！一个封装包裹的过程。在这样的一个过程中，我们能够明确感受到：封装，封装。“封”是形容“装”的，这是两个动作，先装再封。“装”的目的是为了把散的东西统一在一起，是为了方便处理和使用；而“封”的目的才是为了信息隐藏，但信息隐藏也绝对不是说藏的严严实实，也可以是分各种级别的。比如说：上图中的箱子，如果换成一个透明的玻璃箱，可以不？还不是一样的叫“封装”呀。 接下来，我们就结合一下编程思想和语法，来讲讲面向对象编程中的这两个动作“装”和“封”，帮助大家再次理解一下。 如何理解“装”面向对象中“类”的定义就是“装”其实在计算机语言的发展过程，很多内容都是一步一步发展到今天这个程度的。 早期的计算机，由于主要处理的问题域的限制（当时主要是科研用途🔬），导致当时处理的数据主要都是数字呀，字符呀这些，所以在编程语言中都会有现成的整数类型、实数类型、字符类型。使用这些基本的数据类型，我们就足够在计算机中保存和处理科学计算问题所需要的数据了。 后来随着发展，计算机开始进入我们的生活了，那么编程人员要写软件满足大家在生活中的需求。那么他们所遇到的问题域也越来越复杂了，比如：大家要玩游戏🎮，里面有一种数据叫：“武器🔪”。可是用什么数据类型来表示武器呢？武器有名字，有等级，有攻击力等等一大堆内容组成。而以前的数据类型（基本数据类型）只能表示”武器”的某一个方面呀，不能表示“武器”这种东西的整体。更何况，类似于这样的情况在各个问题环境中比比皆是，银行系统需要“用户”类型、酒店系统需要“房间”类型、空管系统需要“航班”类型，太多太多了……咋办呢？干脆让编程语言提供一种可以让程序员“自定义”的复杂类型吧。你们（程序员们）可以根据自己的需要来定义这种复杂类型，把各种需要的数据都装入到这种类型中，然后自己起一个名字来表示就行了呗。C语言就提供了大名鼎鼎的“结构体”语法来干这件事情：12345struct weapon&#123; char weaponName[20]; //武器名称 int weaponLevel; //武器等级 int weaponATK; //攻击力&#125; 再后来，编程人员发现很多这种复杂类型其实除了装“数据”以外，还提供了很多功能呢。比如刚才说的“武器”，它还有攻击功能，发大招功能，升级功能等等，所以单一的仅仅只能装入数据的类型设计语法已经不能满足我们了（傲娇～～～）。因此，到了面向对象的编程语言，就提供了“类”这个新东东。即让“武器类”这个类型可以装入武器的所有数据，又能装入“武器类”的所有功能，把所有属于“武器”的内容都装入到里面。 1234567891011121314151617class Weapon&#123; String weaponName; int weaponLevel; int weaponATK; void attack()&#123; //攻击的实现 &#125; void specialAttack()&#123; //特效攻击的实现 &#125; void levelUp()&#123; //升级的实现 &#125;&#125; 这样一个武器的变量，既可以保存武器的全部属性数据，又可以操作到它的行为。你说，“类”的定义是不是就是一种“装”？！😤 语法中出现{…}就是“装”如果我们再把眼光放开一点，我们会发现“装”这个动作，在编程当中其实是很多的，绝不仅仅是类的设计定义上。比如：循环语句块。这个语法中不就是把一堆代码作为一个整体（“装“在一起），每次循环就执行一次吗？123for(int i = 0; i &lt; 100; i++)&#123; //循环语句块」 再比如：方法块；不也是把一系列的语句作为一个整体，每次调用方法就把这些语句块执行一次吗？123void method(int param)&#123; //方法实现的语句块&#125; 甚至不仅仅是语句块，下面这个语法不也是把一堆int数据”装”到一个数组集合中统一处理吗？1new int[]&#123;13,24,56,-12,7&#125;; 所以，我们说编程语言中{…}这个语法的设计目的，就是把它里面的内容当成一个整体，以便于进行统一的操作使用。这不是“装”是什么？！这是在模块化编程中就已经出现的、自然的、普遍的概念，到了面向对象编程阶段仍然还在延用而已。只是说，在面向对象编程以前没有“封”的语法，所有“装”好的内容，都可以被随意访问到而已。 如何理解“封”为什么要“封”总有很多刚开始接触编程的同学，对为什么要进行“封”这个动作很不理解。他们在写代码的时候，总觉得不方便。比如JavaBean的规范设计，明明就可以直接用“.”操作符操作到的属性，却偏偏要求写成private（私有）的。然后再添一对get／set（访问器／修改器）方法，简直是“脱了裤子放屁—多此一举”😏。难道真是如此吗？ 是的，就是如此😂😂😂！！！“封”就是为了对外部访问进行有效的控制！生活中，把已经”装”好的东西“封”起来，不就是为了限制里面的内容不被外面的人随意看到或获取到吗？难道你会因为怕麻烦，就让快递不把你在某宝上买的那些不可见人的东西封箱？因为怕麻烦就把家里的贵重物品到处放，而不是装到柜子抽屉里，甚至锁上？（少年，你要么太年轻；要么你是真.傻X）。 “封”当然不是为了方便，它是为了数据的安全性、有效性，为了维护设计者的意图，保证程序的正确性。 “封”体现在哪里在本文一开始的时候，我提到很多面试者被问到“封装”就回答“信息隐藏”，针对这种说法我举双手同意🙆！但如果你认为信息隐藏仅仅只是private或者仅仅是访问修饰符，那我坚决举五肢反对🙅！！“封装”是一种思想，在使用上的体现可以是非常灵活，把它仅仅绑定为某一种语法法或是几个关键字，确实太简单化了。 访问修饰符肯定是“封装”的体现这点毋庸置疑！它们就是为了“封装”而生的，这点从“访问修饰符”这个名字也能看出来。“封装”绝不是“封死”，它也是有范围和级别的呀。所以才有各种访问修饰符来针对不同的情况。 访问修饰符 封装范围 容易理解的场景 private 私有 你的私房钱，只能你用。 默认 同包 你的家门钥匙，只要住在你家的人都可以使用。 protected 受保护 你的遗产，只能分配给你的家里人或子女。 public 公共 除了卫生纸，你能有多大方？ get/set方法也是“封装”的体现1.比如我们针对某个属性只提供get方法，那么这个属性对外部来说就是只读属性。 1234567public class User&#123; private int age = 18; public int getAge()&#123; return this.age; &#125;&#125; 2.我们也可以在set方法中添加限制，让外部的调用者不能把垃圾数据放入对象当中。 12345678910111213public class User&#123; private int age = 18; public int getAge()&#123; return this.age; &#125; public void setAge(int age)&#123; if(age &gt;= 18 &amp;&amp; age &lt;= 80)&#123; this.age = age; &#125; &#125;&#125; 3.让外部使用者无法知道类内部保存数据的方式和格式。 12345678910111213141516public class User&#123; private int year; private int month; private int day; public String getBirthday()&#123; return year + "-" + month + "-" + day; &#125; public void setBirthday(String birthday)&#123; String[] values = birthday.split("[-]"); this.year = Integer.parseInt(values[0]); this.month = Integer.parseInt(values[1]); this.day = Integer.parseInt(values[2]); &#125;&#125; 我们调用的API或使用的框架同样是“封装”12ArrayList&lt;Integer&gt; lst = new ArrayList&lt;&gt;();lst.add(15); 当我们使用ArrayList装数据的时候，我们完全不需要去考虑它的具体实现细节（数据结构是咋样的，增加元素空间怎么相应变大变小的），也看不到它内部的实现。这是为什么？“先人”给我们写好了呀，把所有的细节都封装在了ArrayList当中，你只管用就OK了。 框架也是如此呀。Hibernate框架不就是把大家写起来很烦的ORM映射给封装了吗？在用这个框架前，我们要自己去循环数据查询结果集，自己去匹配哪个表对应哪个Bean类，哪个字段对应哪个属性，大家的时间精力都花在上面了。用了Hibernate以后呢？这些细节，你不用考虑了，只要配置一下对应关系，其它的都由Hibernate自己去做了，它把实现的细节给你封装好了。😊😊😊 总结综上，“封装”是面向对象思想中基本的一个特征。在之前的编程思维中，更多的考虑是“装”，是为了能够让计算机有更好的表现数据的方式，以及更好的代码复用效果。现在到了面向对象，有了“封”的思想和语法，就能更好的保障数据的安全性、有效性、准确性，并能够在此基础上进一步维护设计人员的意图，从而达到设计层面在代码级别对实现层面进行管理控制，降低整个开发风险和成本。]]></content>
      <categories>
        <category>JavaSE</category>
        <category>Java面向对象思想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[你应该知道的一些“位运算”]]></title>
    <url>%2F2017%2F07%2F20%2F%E5%B0%8F%E5%AD%90%EF%BC%8C%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%82%B9%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[相信很多同学在Java基础学习过程中，对于常见常用的各种运算符号都有一定的心得了。特别是我们很容易学习和理解的算术运算符（+，-，*，／，%，++，–），赋值运算符（=，+=，-=，*=，/=，%=），比较运算符（&gt;，&lt;，&gt;=，&lt;=，==，!=），逻辑运算符（&amp;&amp;，||，!），三目运算符（ ？ ：）。但是当看到位运算符的时候，很多没有基础的同学可能有一点懵逼吧😏。其实，位运算在某些时候还是非常有用的。特别是在底层编码的时候，它可以带来很多性能以及语法上的优化。当然，我们应用层的开发人员可能用得比较少。不过，多了解一些还是很有好处的，所以接下来我们就聊聊那些你应该知道的“位运算”。 什么是位运算我们知道程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算说白了，就是直接对整数在内存中的二进制位进行操作。因此，位运算最直接的好处就是节省内存空间，提高运算效率。在学习位运算符的时候，我们就可以根据这个概念，先确定两个前提： 位运算符都是以二进制的方式进行运算； 位运算符都是操作的整数； 位与(&amp;)规则：位与(&amp;)是一个双目运算符，也就是说&amp;符号的左右各有一个操作数。它是把两个操作数在二进制的形式上按位进行比较，如果都是1，则结果的这一位就为1；否则就为0。示例：123456public static void main(String[] args)&#123; int a = 129; int b = 128; System.out.println(a &amp; b);&#125;//运行结果为：128我们来分析解读一下这个程序：变量a的值是129，转换成二进制就是10000001，而变量b的值是128，转换成二进制就是10000000。根据位与(&amp;)运算符的运算规律，只有两个位都是1，结果才是1，可以知道结果就是10000000，即128。位与(&amp;)符号，如果左右两边操作数是boolean类型的true或false的时候，我们完全可以把true看作是一个1，false看作是一个0。这样，根据规则位与(&amp;)就会起到和逻辑与(&amp;&amp;)一样的作用了。它的左右两端必须同时为true，整个表达式就为true，只要有一个false，这个表达式就为false。123456public static void main(String[] args)&#123; System.out.println(true &amp; true);//打印：true System.out.println(true &amp; false);//打印：false System.out.println(false &amp; true);//打印：false System.out.println(false &amp; false);//打印：false&#125;应用：在实际开发中，位与(&amp;)对我们最大的用处是作为逻辑运算符—逻辑与(&amp;&amp;)的补充使用。逻辑与(&amp;&amp;)有一个特点就是短路，而位与(&amp;)就没有短路的效果。所以，当我们需要在与操作的时候要求：不管第1个表达式的结果如何，都必须要运算第2个表达式的时候，我们就可以选用位与(&amp;)符号替代逻辑与(&amp;&amp;)。 位或(|)规则：位或(|)也是一个双目运算符。它是把两个操作数在二进制的形式上按位进行比较，只要有一个是1，则结果的这一位就为1；否则就为0。示例：123456public static void main(String[] args)&#123; int a = 129; int b = 128; System.out.println(a | b);&#125;//运行结果为：129我们来分析解读一下这个程序：变量a的值是129，转换成二进制就是10000001，而变量b的值是128，转换成二进制就是10000000。根据位或(|)运算符的运算规律，只要某个位是1，结果位就是1，可以知道结果就是10000001，即129。位或(|)符号，如果左右两边操作数是boolean类型的true或false的时候，我们同样可以把true看作是一个1，false看作是一个0。这样，根据规则位或(|)就会起到和逻辑或(||)一样的作用了。它的左右两端只要一个为true，整个表达式就为true；必须两个都是false，整个表达式才为false。123456public static void main(String[] args)&#123; System.out.println(true | true);//打印：true System.out.println(true | false);//打印：true System.out.println(false | true);//打印：true System.out.println(false | false);//打印：false&#125;应用：在实际开发中，位或(|)同样是用来对逻辑或(||)做替代的。使用位或(|)操作boolean表达式的时候，效果与逻辑或(||)一样，且没有短路效果。 位非(~)规则：位非(~)是一个单目运算符，语法上它的右边有一个整数作为操作数。运算时，会把这个操作数的二进制按位进行1变0、0变1的操作。示例：1234public static void main(String[] args)&#123; int a = 4; System.out.println(~a);//打印：-5&#125;我们来分析一下： 描述 二进制 4的二进制是 0000 0000 0000 0000 0000 0000 0000 0100 位反后的结果 1111 1111 1111 1111 1111 1111 1111 1011 根据负数二进制转换十进制的规则 先减去1 1111 1111 1111 1111 1111 1111 1111 1010 再取反得到绝对值 0000 0000 0000 0000 0000 0000 0000 0101 所以最终结果为-5。应用：位非运算符当然也可以操作boolean表达式，只不过使用它和使用逻辑非(!)没有什么区别，所以在应用层开发中这个运算符使用率并不高。 异或(^)规则：异或(^)是一个双目运算符。运算时，它是把两个操作数在二进制的形式上按位进行比较，如果都是1或都是0（相同），则结果的这一位就为0；否则两个对应位不同（一个0和一个1），结果位就为1。示例：123456public static void main(String[] args)&#123; int a = 15; int b = 2; System.out.println(a ^ b);&#125;//运行结果为：13分析解读一下这个程序：变量a的值是15，转换成二进制为1111，而变量b的值是2，转换成二进制为0010，根据异或的运算规律（相同为0，不同为1），可以得出其结果为1101 即13。应用：异或(^)运算有两个非常有趣的结论： 任何一个数异或(^)它本身，结果是0； 任何一个数异或(^)0，结果是它本身。 a ^ a 的结果是0；a ^ a ^ a 的结果是 a；a ^ a ^ a ^ a 的结果是0；a ^ a ^ a ^ a ^ a 的结果又是a。所以，异或(^)运算符又被称之为“翻面”，每异或(^)一次自己就翻一个面。 左移(&lt;&lt;)规则：将运算符左边的整数（二进制形式）向左移动运算符右边指定的位数（在低位补0）。示例一：1234public static void main(String[] args)&#123; System.out.println(5 &lt;&lt; 2);&#125;//运行结果为：20分析解读一下这个程序： 描述 二进制 5的二进制是 0000 0000 0000 0000 0000 0000 0000 0101 左移2位 0000 0000 0000 0000 0000 0000 0001 0100 所以结果是：20。 示例二：1234public static void main(String[] args)&#123; System.out.println(-4 &lt;&lt; 2);&#125;//运行结果为：-16分析解读一下这个程序： 描述 二进制 -4的二进制 1111 1111 1111 1111 1111 1111 1111 1100 左移2位 1111 1111 1111 1111 1111 1111 1111 0000 根据负数二进制转换十进制的规则 先减去1 1111 1111 1111 1111 1111 1111 1110 1111 再取反得到绝对值 0000 0000 0000 0000 0000 0000 0001 0000 所以结果是：-16。应用：左移（&lt;&lt;）运算就是一种乘法运算，任何一个整数左移多少位，就是把这个整数乘以2的多少次方。这种运算在效率和性能上都比算术运算中的乘法（*）要高很多。 右移(&gt;&gt;)规则：将运算符左边的整数（二进制形式）向右移动运算符右边指定的位数。使用符号扩展机制，也就是说，如果值为正，则在高位补0，如果值为负，则在高位补1。示例一：1234public static void main(String[] args)&#123; System.out.println(13 &gt;&gt; 2);&#125;//运行结果为：3分析解读一下这个程序： 描述 二进制 13的二进制 0000 0000 0000 0000 0000 0000 0000 1101 右移2位 0000 0000 0000 0000 0000 0000 0000 0011 所以结果是：3。 示例二：1234public static void main(String[] args)&#123; System.out.println(-13 &gt;&gt; 2);&#125;//运行结果为：-4分析解读一下这个程序： 描述 二进制 -13的二进制 1111 1111 1111 1111 1111 1111 1111 0011 右移2位 1111 1111 1111 1111 1111 1111 1111 1100 根据负数二进制转换十进制的规则 先减去1 1111 1111 1111 1111 1111 1111 1111 1011 再取反得到绝对值 0000 0000 0000 0000 0000 0000 0000 0100 所以结果是：-4。应用：右移（&gt;&gt;）运算就是一种除法运算，任何一个整数右移多少位，就是把这个整数除以2的多少次方。这种运算在效率和性能上都比算术运算中的除法（/）要高很多。注意：同学们会发现右移一个正整数确实会得到除法的效果，但是右移一个负整数得到的结果会比除法的效果要小一个数。13 &gt;&gt; 2 得到 313 ／ 4 得到 3-13 &gt;&gt; 2 得到 -4-13 / 4 得到 -3这是因为计算机在除不尽的时候统统采用的是向下取整，而我们人则习惯于直接去掉小数部分。不同的计算机语言在设计除法运算的时候有些会直接按计算机的方式来，有些会按人的习惯来。这里很明显，Java语言在设计除法运算符的时候采用了人的自然习惯。 无符号右移(&gt;&gt;&gt;)规则：将运算符左边的整数（二进制）向右移动运算符右边指定的位数。采用0扩展机制，也就是说，无论值的正负，都在高位补0。示例：1234public static void main(String[] args)&#123; System.out.println(-4 &gt;&gt;&gt; 2);&#125;//运行结果为：1073741823分析解读一下这个程序： 描述 二进制 -4的二进制 1111 1111 1111 1111 1111 1111 1111 1100 右移2位高位补0 0011 1111 1111 1111 1111 1111 1111 1111 所以结果是：1073741823。应用：无符号右移（&gt;&gt;&gt;）由于高位一定会补0，所以最后的结果一定会是一个正数。但它的计算没有任何数学意义，只有逻辑意义。它主要出现在散列、加密、压缩、影音媒体编码等技术上。 位运算的常见使用技巧由于位运算符是直接针对二进制数据进行操作，而计算机内部就是直接以二进制的形式表示数据的，所以使用位运算符在效率上往往要比其他运算符高上很多。只是说使用位运算符做比较复杂的运算时，对于我们“普通人”来说比较难于考虑和理解，所以让很多人望而却步。下面，我们就介绍几个比较简单的、作为“普通人”也能用得上的常见技巧。 使用在逻辑运算中，使用位与（&amp;）和位或（|）替代逻辑与（&amp;&amp;）和逻辑或（||），从而达到不短路的效果。—日常开发中常用 使用异或（^）完成两个变量的交换。—面试常见123456789101112public static void main(String[] args)&#123; int a = 10; int b = 7; a = a ^ b; b = a ^ b; a = a ^ b; System.out.println("a = " + a); System.out.println("b = " + b);&#125;运行结果：a = 7b = 10 计算绝对值；12345678public static void main(String[] args)&#123; int x = -5; int y = x &gt;&gt; 31; int result = (x + y) ^ y;//或（x ^ y）- y System.out.println(x + "的绝对值是：" + result);&#125;运行结果：-5的绝对值是：5 判断int变量是否是奇数或偶数；a &amp; 1 == 0;——偶数a &amp; 1 == 1;——奇数 求两个int的平均数；12345678public static void main(String[] args)&#123; int x = -5; int y = 21; int result = (x &amp; y) + ((x ^ y) &gt;&gt; 1); System.out.println("x与y的平均数是：" + result);&#125;运行结果：x与y的平均数是：8 m乘以2的n次方 等价于 m &lt;&lt; n; m除以2的n次方 等价于 m &gt;&gt; n; x = (x == a) ? b : a 等价于 x = a ^ b ^ x;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[（转）当编程语言变成二次元萌妹]]></title>
    <url>%2F2017%2F07%2F07%2F%E5%BD%93%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9%2F</url>
    <content type="text"><![CDATA[试想一下，当Java、C++、Python、Ruby、PHP、C#、JS等编程语言变成了动漫人物会是怎样的一幅场景呢？下面就一起看看在日本作家渡辺将人的笔下，各种编程语言都是哪类“美女”的吧！ Java 犹如宫泽贤治的《不畏风雨》中出现的、性格木讷的女孩子。从小就由于迟钝和大食量等特征被别人当作笨蛋，从小学入学开始进入田径部、坚持跑步，在中长跑中经常取得好成绩，给人以活泼的印象。是十分努力的女孩子。她的家境并不算好。父亲Sun是有才能的艺术家，但不擅长理财，在她14岁的时候因为苦于借债积劳成疾而去世。她被Oracle叔叔收养，那时还与Google叔叔之间因为对她的扶养权问题而引起争端并闹上法庭。在周围的人都担心，正值青春期时她在这样的处境下会不会一蹶不振的时候，她却处变不惊、继续着每天练习跑步的生活。朴素的、认真的、难说是聪明的她，进入高中后不知是不是稍稍开始对异情在意，被人看到她偷偷地学着别的女孩子的时尚穿着在街上行走。虽然会受到“虽然很努力，也许稍微有点过时”、“那衣服与Java的印象不合”之类的否定评价，但感到“意外地很萌？”的好意的人也很多。喜欢喝咖啡，只喝印度尼西亚产的。其本人曾说过“喜欢咖啡胜过三顿饭”，不禁让人稍稍担心“这样对健康没问题吗？” C++ 苗条的双腿和协调的五官。被许多人称作“IT界首屈一指的美女”的她，也因为拥有插花、茶道、钢琴和小提琴、柔道、剑道、合气道等等才能而出名。她的粉丝大多很狂热，还存在着“黑暗军团”这样的粉丝俱乐部。黑暗军团的是规模仅次于共济会（Freemason）的巨型团体，一般人无法入会。据说如果能回答出对她非常狂热的问题，就会有察觉到的军团成员来询问“你愿意进入黑暗军团吗？”与她同父异母的姐妹Objective-C一心专注于弹钢琴，她的专注被IT界的天才史蒂夫乔布斯（也被一部分人称为紫色蔷薇）相中，而一跃成为明星，而C++则是由于其美貌和才能被人关注，长年坐稳业界明星的宝座。姐妹二人真可谓是对比鲜明。她根据心情不同频繁地变换发型和服装这一点也很出名。昨天还是和服配黑发，今天却是红发哥特系登场之类的，因为她的变身而使轻度的粉丝惊奇道“啊嘞？今天是C++小姐吗？”的事也常有发生。远离业界时私下经常穿HYSTERIC GLAMOUR的服装。关于她的出身年月日其事务所并不公开。虽然也有出身于1983年一说，本文采用的是在一部分粉丝中流传甚广的1985年10月14日说。其间也流传有“她自己也许也记不清自己的生日……”这样煞有介事的传言。与其说“C++小姐的话记不清自己的生日也不是什么不可思议的事情”，倒不如看作是她天真烂漫的性格的表现。 Python 由Guido父上养大的深闺中的大小姐。她出身于荷兰的阿姆斯特丹，但在小时候就搬到了美国，父亲也在家里使用英语，所以不怎么会说荷兰语。她个性随和。最出名的是她听C++宣布“想出去旅行一趟改变一下形象。200x年回来哦”出门旅行后（结果回来的时候已经2011年了……），放言说“我也稍稍出门旅行一下，公元3000年再回来哦”后出门数年未归。虽然有着这样冒失的行动，但多亏抱着“养成大家都喜爱的孩子”的心愿的Guido父上大人的教育，实际上和她接触后会觉得她非常容易亲近。前些天，她来到作者的朋友的公司打工（她现在似乎在边上大学边打工），被人们评价为“能充分融入工作、八面玲珑、给我们帮了大忙”。她不怎么说多余的话，彬彬有礼的样子，被评价为是在“天真烂漫、自由第一”的人众多的业界中与众不同的存在。据说她擅长的科目是数学，经常看到她轻松地解决各种统计相关的难题。喜欢穿白色的连衣裙或浅粉色的开衫这样清新的服装。实际上她还喜欢爬行动物，据说在家里还有养蛇。粉丝们经常讨论“她会给宠物们起什么样的名字呢？”这样的话题。大多得出的都是“肯定是Monty吧”这样的结论。会不会飞就不得而知了。 Ruby 由松本爸爸养大的日本的女孩子。因为生日在圣诞节，人生最大的烦恼是生日礼物和圣诞节礼物变成一份了。出生地是岛根县松江市，除了旅游和工作以外没有到过其它的县。由于受的教育是自由奔放式的，她性格好动、好奇心旺盛。平时是一个率真的好孩子，但偶尔也会看到她喜欢恶作剧的一面，这让周围的人十分困扰。看到她的身影时经常会想起IT业的“Just For Fun !”这句话。小时候过着一个人在荒山野岭到处跑的生活，10岁的时候与一个叫Rails的女孩成为朋友，生活开始变化。两个人玩耍时停在了演艺事务所门前，谈起可以两个人结对进行演艺活动。以“Ruby与Rails”的艺名出道、主要从事杂志模特，也有拍过电视广告，所以很多人都听过她们名字。人们想着她在这多愁善感的年龄段体验各种演艺活动、性格多少会产生一些变化吧，但在前些天与她久违的谈话中，却惊讶地发现她仍是与从事演艺活动之前一样行动自由奔放。虽然行为举止多多少少显得更加稳重，其喜欢恶作剧、活泼的本性却和以前一样没有变化。想着已经是高中生了差不多也要开始穿一些成熟一点的服装的她，对于洋装却和小时候一样穿着Mickey Mouse。虽然她个子小又是娃娃脸与这样的衣服很配，不过这样真像一个女高中生吗？她的粉丝也分为想要她一直保持现在的样子，和想要看到她更成熟的样子的两派。 PHP 以强化Web世界为目的制作出来的女性机器人。竖着的头发是用作天线来随时接收主人的命令的。为了有与人类相近的触感，使用了硅树脂来制作其皮肤。内部是类似于刀片服务器的构造，常常使用多台服务器进行复用。因此体重比人类更重一些。在她最初登场的时候，还能看到她关节可动部分的骨架，行动也很僵硬，与人类的形象差别很大。然而经过了18年间6次的大版本升级之后，其行为和言语已经渐渐变得像人了。最近更是达到了像初音未来这样（比起人类仍然有少许违和感但已经十分自然了）的级别。虽然笨笨的、工作时也磕磕绊绊的，但由于她遵循机器人三原则、服从主人的命令，也有很多人成为她的粉丝。她的粉丝俱乐部官网“PHPer！”无需入会费便可简单入会，是会员数在IT界首屈一指的大团体。对于她持拒绝态度的人也很多，常有“她的行为在生理上有些难以接受”、“如果再聪明点就好了”、“与她稍有过接触但觉得还是与人类差别很大”这样的评论。平常穿从Forever12和志村买来的衣服。想着穿便宜的快速时尚（fast fashion）衣服便可以将省下的钱花在机器开销上。可以说是标准的机器人的效率优先的花钱方式。或许会有她也在意流行、为样子烦恼的那一天吧？ C# 在著名的微软公司接受精英教育、11岁时便跳级进入大学学习、倍受人们关注的少女。也被称为“IT界的最强幼女”。因为与C++的名字很像，一段时间内盛传“难道是私生子吗？”的流言，实际上两人没有直接的血缘关系。也有报道称两人是远房亲戚，但实际情况如何则不得而知。似乎喜欢成熟的行为、讨厌像小孩子一样玩耍。有生日的时候收到父母送的名为安迪的毛绒玩具时说道“这是啥。没sense。不要”的传闻。然而对于食物的兴趣却仍停留在小孩的阶段，多次目击到她在学校食堂点儿童套餐的样子。不喜欢喝咖啡，就算是甜味的罐装咖啡也会令她皱眉头。虽然偶尔会见到她意外地孩子气的一面，多数情况下见到的还是她说话、待人接物彬彬有礼的样子。是一个既有成熟的一面又有稚气的一面的孩子。由于还在成长期，见到她时常有“又长高了啊”、“有些像大人的样子了”这样的感慨。一直会期待着下见到她时会长成什么样子。常穿秀兰邓波的洋装。据说都是她本人挑选的，与她自己非常相配。她的可爱让人们无论男女都会成为她的粉丝。她的志向是在大学毕业后不仅在养育她生长的微软公司的旗下工作、还要活跃于整个IT界。虽然没有问到更详细的计划，但据说是要做出能让苹果和企鹅等也能和睦相处的东西。到底会做出怎样的东西来呢？ JavaScript 在争议地区长大的17岁的女孩子。常常面无表情、谈话时总给人以一定的距离感。虽然与Java的名字很像，两个人之间却没有血缘关系。在当时Java这样的名字很流行，所以父母也给她起了类似的名字。她本人似乎对自己的名字并不在意，有时也以“ECMA”的笔名进行活动。偶尔也会被叫“JS”的外号，对此则更不在意，甚至对这种称法公然无视。她的生涯非常不幸。刚一出生祖国便爆发战争。懂事之前便母亲去世、离开了父亲。在大人们任性的争斗中，她学会了将自己藏在壳中、保护自己周围的生存之术。同年龄的女孩子随着年龄的变化都在挑战各种风格的时候，她却不顾周围的话语、一个人继续闭锁在壳中。当时就是非得这样才能生存的艰难环境。由于有了这样的儿童时期，她的说话、思考、待人接物的方式与其它的孩子都稍显不同。有很多人在与她说话时都会烦恼该怎样说才好。不过，也有人对她持有简单的一根筋的思考方式“容易接触”、“某种程度上来说，很好理解”的印象。现在，她的国家正向努力解决纷争、开拓新的居住土地的方向前进着。大人们虽然仍旧任性地互相斗争，至少在这几年里，已经没有发生像以前那样互相憎恨、互相残杀的战争了。在开始复兴的祖国里，她如今应该能幸福地生活着吧？什么时候才能看到她像同龄的女孩一样欢笑呢？ Perl Perl于1987年12月、美国的沃尔夫妇家中诞生。其父亲拉里精通计算机、语言学，母亲也从事中世纪文艺复兴和语言学专业，Perl就是在这样接受了高等教育的父母身边长大的。父亲的教育虽然严厉，却也给了Perl许多自由。父亲在教育过程中经常说的一句话是：“方法不止有一个。”（There’s more than one way to do it)想到实现什么时，达成的方法不只有一种。可以考虑各种方法。父亲的这种教育方式，对她的性格形成产生了很大的影响。“这样做的话会怎么样？”……“那样做又会如何？”……张开好奇心的翅膀长大的她渐渐发现了自己“发明”方面的天赋。绝代的发明家、Perl诞生了。从她踏上发明家的道路的20年来，其发明多达128890件（2014年1月统计数），她的发明，从没什么用处的玩具，到能解决世界上许多问题的有益的发明，应有尽有。她发明的物品的原型，全都捐赠给了CPAN博物馆，任何人都可以阅览。如今仍然不论实用与否、不断做出想做的新发明的她自打趣地在采访中说道：“我比起发明家，更像是各种破烂的生产装置。”她露出牙齿的笑容，非常振奋人心。Perl对洋装不怎么讲究，平时因为调整机械时觉得麻烦，会穿便于运动的休闲装。最近常穿的羽绒服据说是在ame横（东京上野的一条商业街）的WEGO买的。喜欢的食物是草莓。她说作业中对集中注意力而疲劳的大脑来说最适合的食物就是草莓。 C 支撑着这个世界的女神大人，也被称为“圣母大人”。关于C的出身年月没有定论。有人说她在创世纪（指1970年1月1日左右）之前就存在于这个世界，也有人说她是在稍后的1972年左右诞生的。她是女神大人，因此像“1970年左右出身的话，她现在的年龄是……”这样的想法是不信教的行为。绝对不要有这样的想法。她的名字是字母表的第三个字母“C”。据新约史书上的记载，在她之前还有叫作B的女神大人。一些资料显示“肯和丹尼斯创造了B，但对此并不满足。此后丹尼斯和其它人又合力创造了C”。世界上有许许多多她的信徒。然而在一段时间内都没有正确传达她的教诲的圣经。当初丹尼斯和布莱恩留下的诗篇虽然担负着这样的使命，人们却希望有更加明确的言语。此后有许多有识之士将各种逸闻编辑整理、编著出了正确传达她的教义的圣经。本书至今已被修订过多次，根据修订年的不同，被称作C89、C99、C11等。一般人与C不能直接对话。只有积累了足够的修行者才会被允许与C交流。修行是十分严格的，需要理解”指针的指针“之类的问题，以及要求100%地成功解决无论多么努力地修行都难以克服的“malloc/free”问题。由于这样的背景，真正能跟她进行日常交流的人非常地少。然而由能够交流的人经手、世界上诞生了多种多样的知识与技术。即使你没有见过她的样子，她的慈爱也确实地每天都围绕在你身边。 Visual Basic 姓氏是Basic，名字是Visual，也有很多人叫她的绰号：VB。小名是Ruby（与那个Ruby没有关系）。从小被某个资产家（不能说他的名字）看上，一家人都寄身于资产家的身边。那时她的名字换了好多次，如今才定下这个名字，有着比较复杂的家庭环境。关于资产家要收养尚处于幼年的她原因，据不可靠的传言称，他从她身上看到了从前就很憧憬的Basic女士的影子。收养与具有与憧憬的女性相似气质的小孩，也即实行所谓的光源氏计划。也许年轻人并不了解，Basic女士曾是《微电脑Basic杂志》的封面模特，在当时是每个人都非常向往的麦当娜一样的女性。实际上我的认识的人里面年轻时为她倾倒的人非常之多。VB在接受严格教育的同时，也在关于兴趣方面拓展天性，她在手工制品、装饰品方面有着独特的才能。看着她制作珠子的装饰品的样子会觉得犹如魔法一般。仅仅是动动手，一瞬间就可以做出一串项链。在她10岁的时候，资产家的家里来了一位新的养女。（人们常说的那位）由于这个原因，她现在正在家中努力做一位好姐姐。然而本来便懦弱、不擅长说话的她却时常反过来被小她10岁、认真的、发言时间长的妹妹说教。加油啊，VB小姐。小时候的VB会穿着父母买的Emily Temple的衣服，现在更多时候穿着是自己买的Lowrys Farm的衣服。今年就要大学毕业进入社会了，目标是VB小姐特有的成熟路线。 R 她于2000年2月29日出身。正是残存在人们记忆中400年一遇的被诅咒的那一天。虽然出身于非常不吉利的日子，她自己却成长为人见人爱的聪明的孩子。她的母亲名叫S。虽然在神话的世界里C是在B之后出生的，她的名字却是S的前一位R。这几个都是很难用Google搜出来的名字。（注：因为太短了！）她的母亲非常擅长数学，是统计学者的助手，R也继续了这一性质。她从小时候起就很擅长数学，小学时代就已经达到能快速解决高中数学问题的级别。此外，她对几何图形也很感兴趣，经常有人看到她画着各种二维、三维图形、画好后一个人露出满足愉悦的表情。是一个稍微有点奇怪的孩子。R在擅长数学的同时却也对语言表达方面稍显逊色。前些日子采访她的时候，她对提出的问题想要回答却找不着合适的词，取而代之“刷——”地画了一幅散点图说“这样的感觉”。或许在她的眼里，这个世界里用语言来表达就像折叠复杂的数学公式那样复杂吧。她对服装不怎么讲究，常常穿着不紧不松的连衣裙和衬衫。对于父母给她买的洋装是多少价格、哪儿买的这样的问题没有认识。仅仅是，对于最近买来的喇叭裙的裙摆张开的角度很在意。她的梦想是将来成为一名统计学者，尽管只有14岁却经常混迹于大学学生中间每天都在解各种问题。最近光是大学已经不能满足、又向父母请求、在各种各样的研究所里进出。 Scala O教和F教之前有着长着的宗教战争。Scala是这两个宗教的牧师和修女结婚诞生的异端。她出身后立即引起了两家之间激烈的对立，察觉到危险的父母将她送到私立JVM学校的Odersky老师那儿作为养女寄养。现在两个宗教比起当时已有了关系改善的征兆，有一部分人也将她视为两家融合的象征。然而抱有强烈的对立心态的人仍然很多，也常常有针对她的存在引起的争论。F教的人们认为她的存在没有充分认识F的本质，而O教的人则对混有F的她感到难以理解。虽然诞生于这样复杂的环境，她自己对于周围的环境却不关心，而是十分平静地到双方的教会中取面包、坚强地生活着。被她这种天真烂漫的姿态所感动、成为她的粉丝的人也很多。Scala似乎喜欢同校的高年级部里上学的Java小姐，休息时间经常去找她。Java小姐也并不讨厌她，经常会像大姐姐一样让她坐在她的膝盖上温柔地抚摸她的头。虽然在Scala把Java喜欢的Duke的人偶用红绳子绑起来进行恶作剧时把Java惹得十分生气，在此以外则几乎没怎么吵过架。两个人就好像亲生姐妹一样。有着见多识广的父亲和温柔的姐姐的Scala现在也许是，与其出身的复杂情况相反、实际上非常幸福地生活着吧。她对于洋装喜欢明快的颜色和花纹，经穿着Algonquin的衣服。虽然是比较有个性的时装，由与生俱来的有个性的她穿来却不可思议地自然。 Shell 创世纪（1970年1月1日）起经过数年后被目击到的妖精。会寄宿在家中，有着类似于棕精灵（Brownie）的生活方式，向她们拜托家务事或着杂活的时候，会回答两次并接受的温顺的孩子的。她们不常出现在人间存在的地方，因为不通言语，会用信件交流。如果拜托的事情说得比较含糊的话，有可能会造成误解而发生不得了的事情。对此的技巧是明确地像“做那个|做这个&gt;放在这里”这样有顺序地将要拜托她们做的事写好。如果对拜托的事理解得很好的话，她们会在夜里将事情都处理好。如果很好地完成了工作的话，请别忘了在第二天的晚上放上作为谢礼的方糖。Shell中有各种各样的种族。现在已确认的种族中比较有名的有：“ba”、“c“、”k”、”tc”、“z”等等。其服装根据种族不同而不同，我所目击到的是一只身高60cm左右、穿着巴宝莉的儿童服装的个体。恐怕人们目击到最多是”ba”种。个人而言我也想遇到身高更高一些、尖耳朵的“z”种，现在虽然知道如何写信，却从未见过实物。尽量她们会在同一个屋子里居住，却很少有人有机会见到，也不如何才能遇到他们。有一种说法是，每天都把写程序这一仪式进行到午夜、勉强靠咖啡因支撑着抬起头的状态下突然向屏幕看去，能够看到她的身影。确实我遭遇她，也是在公司里熬夜写程序的时候。Shell的个体非常地多，据说每家每户都会有一只。在大家的家里，实际上有着许多的她们居住着、等着来信也说不定。 ActionScript 在争议地区诞生的13岁女孩子。她的父亲是有名的设计师，但是她5岁的时候被卷入战火身亡。幸运的是她那时年纪还小、将她收养的Adobe叔叔非常用心地将她养大，没有在她心中留下很大的伤痕。叔叔和她父亲同样都是设计师。也许在她的记忆中已经把两个人混淆一起了也说不定。她所居住的国家与JavaScript所居住的国家是邻国，两国同样是ECMA人种构成的。在外国人看来JavaScript和ActionScript的外貌非常相似。确实在看她们儿童时期的照片，在肤色和五官上都很相像，但如今长大了的照片看了的话会如何呢。她把“为祖国和叔叔努力”作为座右铭努力着，然而努力却经常得不到回报，是一个运气不太好的孩子。在争论地区盛传将实行新的公用语的时候，她希望为即将到来的和平时代出一份力，比谁都更早开始学习这门语言，然而在好不容易能说好这门语言的时候，这语言被采用为公用语的提案泡汤了。在她刚开始学习移动端上的设计时，她想着在移动方面强大了会对叔叔的工作有用。也可以减少祖国的外贷。在这样的想法中努力的时候，叔叔经营的公司却被某个巨型移动终端公司强行终止的交易，关于移动端的工作也急剧减少。十分努力却常常得不到回报的她，伫立于这片如今也看到到纷争停止的土地上，继续地前进着。有朝一日努力会得到回报的吧。祝福她在10年后仍能平安，不断地前进着、生活着。]]></content>
      <categories>
        <category>冷趣小知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[（转）世界上第一位程序员竟然是个妹子]]></title>
    <url>%2F2017%2F07%2F04%2F%E4%B8%96%E7%95%8C%E4%B8%8A%E7%AC%AC%E4%B8%80%E4%BD%8D%E7%A8%8B%E5%BA%8F%E5%91%98%E7%AB%9F%E7%84%B6%E6%98%AF%E4%B8%AA%E5%A6%B9%E5%AD%90%2F</url>
    <content type="text"><![CDATA[在程序员这个男多女少的世界里，男女比例的极不均衡让男程序员们自然而然地成为了这个世界的主宰。细数下来，从C语言和Unix系统的创造者Denis和Thompson，到后来的Linux系统之父Linus，再到Java之父Gosling，都是广大男程序员中杰出代表，是程序界的豪杰。按照这种逻辑，想必世界上第一位程序员也必定是我们男同胞吧！哈哈，认真你就猜错了，据史料记载，世界第一位程序员的的确确是一个妹子，名叫阿达·洛芙莱斯(Ada Lovelace)，就是下面这位。废话少说，下面就让我们看看她是如何成为一位伟大的程序员的吧，或许如果不是她，这世界上也许就没有程序员这个职业了呢！ 我就是世界上第一位程序猿，你是第几位呢?在我看来，阿达被称为世界上最伟大的程序员是毫不为过。她为了给程序设计“算法”，制作了第一份程序设计流程图，作为计算机程序的创始人，她建立了循环和子程序等现代编程领域极为重要的概念。不过重要的是人家不仅仅是一个程序员，还擅长思考，在数学和逻辑学方面也颇有天赋，此外她的颜值也很高，美貌过人，是英国著名诗人拜伦的女儿。其实天资聪颖的她本该按照母亲的意愿成为一名数学家的，之所以变成一名程序员还得从巴贝其和他的分析机说起。出生于伦敦的阿达，在17岁时于剑桥大学第一次见到了著名的数学家、发明家兼机械工程师查尔斯·巴贝其，而这次相遇成了阿达人生的转折点。巴贝其当时正致力于发明分析机，而阿达则致力于为这台分析机编写算法。在这个过程中，阿达第一次接触到“差分机”这个概念，阿达日后的在和巴贝奇教授讨论差分机的过程中，预言了通用计算机可能。譬如她建议建议用二进制数代替原来的十进制数，表明分析机可以接受各种各样的穿孔卡：“控制卡”、“数据卡”、“操作卡”。她还提议数字和其他符号如字母都可以“编码”成数字数据，机器可以处理它们。甚至早于现代计算机出现200年，提出了分析机的记忆能力的想法，指出分析机应该有存储位置或地址，并且有“注解或备忘”的可能性。尽管由于当时技术的局限性无法满足分析机队精度，导致分析机最终无法实现，但是阿达在这个过程中提出的种种编程概念以及她对于计算的理解，对日后编程界产生了巨大的影响。从这一点上看，阿达当之无愧成为世界公认的第一位程序员。后来美国军方为了纪念阿达的杰出贡献，将历时20余年开发的一种新型的高级编程语言命名为——Ada。所以说妹子们如果以后有男程序员吹嘘自己的偶像代码写的多么厉害的时候，那就应该告诉他世界上第一位程序员还是一个妹子呢？你看她多厉害啊！你们都是跟她学的。]]></content>
      <categories>
        <category>冷趣小知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一副图片看开源]]></title>
    <url>%2F2017%2F07%2F01%2F%E4%B8%80%E5%89%AF%E5%9B%BE%E7%89%87%E7%9C%8B%E5%BC%80%E6%BA%90%2F</url>
    <content type="text"><![CDATA[这是一副在网络上流传多年的图片，你能看懂吗？咋一看，这是一副什么图呀？4个形象有趣的卡通人物坐在一起喝着咖啡聊着天，墙上挂着的照片又是“真人秀”，总感觉有什么寓意藏在其中……其实这幅图确实是暗藏玄机，它的场景当中暗含了许许多多软件世界中的重要技术、著名人物和组织。这些技术、人物、组织都有一个共同点，那就是“开源”。所以，我们可以说这是软件开源世界中的一个大集合。【手动微笑】 什么是开源一说到“开源”两个字，很多人的第一反应是“免费”（你们呀，真是够了……）。那么到底什么是开源呢？ 开源(Open Source)：它是软件项目上的一种公共协作，用于描述那些源码可以被公众使用的软件，并且此软件的使用、修改和发行也不受许可证的限制。 在计算机发展的早期阶段，软件几乎都是开放的，任何人使用软件的同时都可以查看软件的源代码，或者根据自己的需要去修改它。在程序员的社团中大家互相分享软件，共同提高知识水平。这种自由的风气给大家带来了欢乐，也带来了进步。 但不久之后，以微软为主的一些商业公司就破坏了这种风气。这些商业公司从自由的计算机社团里雇佣了大量的技术高手，开发带有知识产权保护的专有软件。他们在分发软件的时候也不再附带源代码。从此，专有软件的时代到来了。直到现在，专有软件不公开源代码仍是默认的行业潜规则。 即使这样，崇尚自由的斗士们也没有妥协。他们认为，数字时代本应是自由的，任何人都可以自由的获取软件资源及其源代码，而不应该被少数商业公司所控制。因此由 Stallman为领袖的一群富有激情的技术高手们发起了自由软件运动，创立了“自由软件基金会”，即Free Software Foundation(FSF)。FSF 颁发了 GNU GPL 通用公共许可，GPL 明确定义了自由软件的含义，即用户拥有使用软件、修改软件、重新发布软件以及改善再利用软件等四种自由，作为前提的，自由软件必须公开所有的源代码。 GPL 成为自由软件世界中的最高精神纲领，它成功地创建了一个软件中的自由王国，并保证开发者、用户都拥有充分的自由权。另外，在自由软件的世界中，根本就不存在盗版的概念。“自由软件”的英文是“Free Software”，这不免为许多人所误解，人们经常把它和“免费软件”连系在一起，免费的恰恰都是些低级的，这使得自由软件蒙上了一层阴影。于是大家决定给自由软件一个更易理解的别名“开源软件”。开源一词则由此得来。所以，开源即是自由的化身。它讲述了一种公开的、自由的精神。软件开源的发展历程 ，为我们软件行业以及非软件行业的人都带来的巨大的参考价值. 看图说话接下来，就让我们来认识一下这幅图当中隐藏的那些有关开源的隐藏冷趣小知识吧。 四个主角从左至右： 红色小恶魔 FreeBSD是一种UNIX操作系统，是由经过BSD、386BSD和4.4BSD发展而来的Unix的一个重要分支。FreeBSD 为不同架构的计算机系统提供了不同程度的支持。 企鹅 Linux是一种自由和开放源码的类Unix操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。Linux是一个领先的操作系统，世界上运算最快的10台超级计算机运行的都是Linux操作系统。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。Linux得名于天才程序员林纳斯·托瓦兹。 Java Duke 这个就不多说了，Java的吉祥物Duke 红色恐龙 Mozilla基金会简称Mozilla（缩写MF或MoFo），是为支持和领导开源的Mozilla项目而设立的一个非营利组织。该组织制定管理开发政策，经营关键基础组织并管理商标及其他知识产权。它拥有一个称作Mozilla公司的子公司，雇佣了一些Mozilla开发人员并协调Mozilla Firefox网页浏览器以及Mozilla Thunderbird电子邮件客户端的发行版。 背景墙从左至右： 第一幅照片 理查·马修·斯托曼（Richard Matthew Stallman）是美国自由软件运动的精神领袖、GNU计划以及自由软件基金会（Free Software Foundation）的创立者。作为一个著名的黑客，他的主要成就包括Emacs及后来的GNU Emacs，GNU C 编译器及GDB 调试器。他编写的GNU通用公共许可证（GNU GPL）是世上最广为采用的自由软件许可证。 第二副照片 詹姆斯·高斯林 （James Gosling），软件专家，Java编程语言的共同创始人之一，一般公认他为“Java之父”。 牛头 GNU计划，有译为“革奴计划”，是由理查德·斯托曼在1983年9月27日公开发起的自由软件集体协作计划。它的目标是创建一套完全自由的操作系统GNU。 日历 Evolution是Linux的邮件客户端，为gnome桌面环境下电子邮件、个人信息、日程安排、日历等方面提供了一整套高效的解决方案，多年来一直受到linux用户的好评。 壁炉上的摆件骆驼摆件 Perl语言，最初的设计者为拉里·沃尔（Larry Wall），他于1987年12月18日发表。Perl借取了C、sed、awk、shell scripting以及很多其他程序语言的特性。其中最重要的特性是它内部集成了正则表达式的功能，以及巨大的第三方代码库CPAN。简而言之，Perl象C一样强大，象awk、sed等脚本描述语言一样方便。Perl 一般被称为“实用报表提取语言”（Practical Extraction and Report Language），你也可能看到“perl”，所有的字母都是小写的。一般，“Perl”，有大写的P，是指语言本身，而“perl”，小写的p，是指程序运行的解释器。 ####鱼缸中的河豚####OpenBSD是一个多平台的，基于4.4BSD的类UNIX操作系统，是BSD衍生出的三种免费操作系统（另外两种是NetBSD和FreeBSD）之一，被称为世界上最安全的操作系统。 餐桌摆件咖啡杯 Java语言的Logo，就不多说了。 笔筒图案 GIMP 是跨平台的图像处理程序。GIMP 是 GNU 图像处理程序(GNU Image Manipulation Program)的缩写。包括几乎所有图象处理所需的功能，号称Linux下的PhotoShop。 羽毛 Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。 彩色方块 GTK+（GIMP Toolkit)是一套源码以LGPL许可协议分发、跨平台的图形工具包。最初是为GIMP写的，已成为一个功能强大、设计灵活的一个通用图形库，是GNU/Linux下开发图形界面的应用程序的主流开发工具之一。并且，GTK+也有Windows版本和Mac OS X版。 白色方块 XOrg基金会的X11开源实现 （XOrg Foundation Open Source Public Implementation of X11） (the XOrg Server) 是X Window System的官方参考实现。当前的发布版本是X11R7.0，发布于2005年2月10日。它是开放源代码的自由软件。这个项目由X.Org基金会运作，存放于freedesktop.org的主机上。 便签本 OpenOffice.org 是一套跨平台的办公室软件套件，能在 Windows、Linux、MacOS X (X11)、和 Solaris 等操作系统上执行。它与各个主要的办公室软件套件兼容。OpenOffice.org 是自由软件，任何人都可以免费下载、使用、及推广它。 桌布脚印图案 GNOME是一种让使用者容易操作和设定电脑环境的工具，GNOME 包含了 Panel （用来启动此程式和显示目前的状态）、桌面 （应用程式和资料放置的地方）、及一系列的标准桌面工具和应用程式，并且能让各个应用程式都能正常地运作。不管之前使用何种操作系统，都能轻易地使用 GNOME 功能强大的图形接口工具。]]></content>
      <categories>
        <category>冷趣小知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[什么！你用的Java版本叫“Tiger🐯”？]]></title>
    <url>%2F2017%2F06%2F20%2F%E4%BB%80%E4%B9%88%EF%BC%81%E4%BD%A0%E7%94%A8%E7%9A%84Java%E7%89%88%E6%9C%AC%E5%8F%AB%E2%80%9CTiger%E2%80%9D%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[作为一个Java初学者，很多同学的精力都放到了Java语言本身的语法当中，或是开始纠结于各种算法，或是专研OO思想，还有人对各种设计模式趋之若鹜，总之开启了各种“高大上”的装逼模式……少年人，你可知道： “生活不止眼前的苟且，还有诗和远方的田野。”———————— 高晓松 今天就让我们先放下冷冰冰的代码，虚无缥缈的编程思想，来看点关于Java你应该知道的一些“趣知识”吧。 Java之父 这位看上去亲切和蔼的“花样”大叔，相信很多人都认识。他就是著名的Java之父—-詹姆斯.高斯林（James Gosling）。别看人家现在是一脸沧桑，想当初也是以一个“天才”少年的身份闪亮登场的。1955年的冬天，詹姆斯出生在加拿大的一个村庄里。12岁的时候，他用报废的电话机和电视机中的部件做了一台电子游戏机。附近农民的联合收割机出了问题也常常找他修理。14岁的时候，中学组织到附近大学参观，他记住了大学计算中心的门锁密码，从此开始偷偷地溜进计算中心，学习计算机编程。一年后（15岁），大学的天文系招他当了一名临时编程员，编写计算机程序来分析卫星天文数据。1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得了美国卡内基梅隆大学计算机科学博士学位。毕业后到IBM工作，设计IBM第一代工作站NeWS系统，但不受重视。后来转至Sun公司。1990年，与Patrick Naughton和Mike Sheridan等人合作“绿色计划”，发展了一套语言叫做“Oak”，后改名为Java。1994年底，在硅谷召开的“技术、教育和设计大会”上詹姆斯.高斯林展示了Java程序。2000年，Java成为世界上最流行的电脑语言。2009年4月，甲骨文公司花费了74亿美元收购了SUN公司。但由于理念不合，不到一年詹姆斯.高斯林宣布从甲骨文公司离职。2011年3月29日，他在个人博客上宣布将加入谷歌，但几个月以后他又离开了。2011年8月30日，他加盟一家从事海洋机器人研究的创业公司Liquid Robotics，担任首席软件架构师。2017年5月22日，詹姆斯在Facebook上宣布他将加入到亚马逊。厉害吧👍👍👍，这位60多岁的IT大牛太能折腾了。有这么一位祖师爷，各位Java学员你们还怕什么？！😏😏😏 Java吉祥物说到Java，所有同学都应该认识那杯热气腾腾的咖啡杯，那么下面这个小家伙你认识吗？ 它叫做Duke（杜克），是由Joe Palrang在1992年创作出来的。Duke当时所扮演的角色是类似Office中小助手的功能，而那时的Java这门编程语言还不叫Java而被称之为Oak呢。另外大家也许都知道Java是开源的，那你知道Duke也是开源的吗？也就是说我们可以随意发挥我们的想象力，让Duke飞起来✈️～～～ Java全球排名Java初学者常常被教导说：Java是最流行的语言。说这话的人往往是微微一笑，高深莫测的样子；听这话的则是将信将疑，你们是不是王婆卖瓜，自卖自夸呀……那么编程语言有没有排名呢？谁排的，咋排的呢？其实在业内，我们还真有一个可靠的编程语言榜单，它叫做TIOBE排行榜。该榜单是根据互联网上有经验的程序员、课程和第三方厂商的数量，并使用搜索引擎（如Google、Bing、Yahoo!）以及Wikipedia、Amazon、YouTube统计出排名数据。其目的只是反映某个编程语言的热门程度，并不能说明一门编程语言好不好，或者一门语言所编写的代码数量多少。TIOBE开发语言排行榜每月更新一次排名，每年评选一个年度语言。我们来看看目前的最新排名情况： 给你个网址，可以随时可以查看：TIOBE排行榜单; Java版本演化及别名JDK1.0这是第一个发布的版本，发布时间是1996-1-23。当时语言的名字还被叫做Oak（橡树）。直到第一个稳定版本JDK1.0.2被发布出来，才被称之为Java。 JDK1.1这个版本发布的时间在1997-2-19，它主要添加的内容包括： 改进扩展了AWT的事件模型 添加了内部类 引入JDBC（Java数据库连接） 引入RMI（远程方法调用） 引入反射机制 在微软的Windows平台上引入JIT编译器（Just in Time，及时编译器）。 开始支持国际化和Unicode编码 J2SE1.2这是Java历史上的一个“里程碑”式的版本。它发布于1998年12月8日，并且从这个版本开始出现了几个名称上的变化： 从这个版本开始直到J2SE5.0，Java被更改为Java2； 从这个版本开始，版本名称从JDK改为J2SE，以便于区分其它扩展平台J2ME、J2EE。 从这个版本开始，开始公布每个Java版本的开发代号。J2SE1.2的开发代号是“playground”（操场）。意味，SUN公司给各位Java程序员提供了一个广阔的平台，大家High 起来。 这个版本提供的新内容包括： 增加strictfp关键字； 核心类中融入Swing图形API； SUN公司的JVM（Java虚拟机）首次装备JIT编译器； 引入集合框架； 引入Java插件applet支持； Java IDL（交互式数据语言），支持CORBA。 J2SE1.3开发代号为Kestrel（红隼），发布于2000年5月8日。引入新特性包括： HotSpot JVM首次被包含（发布是在1999年4月份）； 修改RMI，使其支持CORBA； JNDI（Java命名与目录接口）被包含在核心库当中； 引入JPDA（Java平台调试体系）； 引入Java声音API； 引入动态代理类。 J2SE1.4开发代号为Merlin（灰背隼），发布于2002年2月6日。引入新特性： 增加assert关键字； 引入正则表达式； 引入链式异常处理； 提供IPV6的支持； 提供非阻塞的输入输出（被称之为新的IO，NIO）； 提供日志API； 提供Image IO API支持读写格式为JPEG和PNG的图片； 提供XML解析和XSLT的处理； 引入安全和密码表达式； 引入Java Web Start； 引入Preferences API。 J2SE5.0开发代号为Tiger（老虎），发布于2004年9月30日。这个版本是Java版本史上第二个“里程碑”式的突破，它不断更新，一直持续到2009年年底，经历了Orcale收购SUN这一重大事件。在名称上，也经历了从原本的J2SE1.5更改为J2SE5.0，到JavaSE5这一系列的变化。引入新特性： 引入泛型； 增强循环，可以使用迭代方式； 自动装箱与自动拆箱； 类型安全的枚举； 可变参数； 静态引入； 元数据（注解）； 引入Instrumentation。 JavaSE6开发代号为Mustang（野马），于2006年12月11日发行，直到2017年1月17日。引入的新特性包括： 支持脚本语言； 引入JDBC 4.0 API； 引入Java Compiler API； 可插拔注解； 增加对Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos和LDAP(Lightweight Directory Access Protocol)的支持； 继承Web Services； 深入优化。 JavaSE7开发代号为Dolphin（海豚），于2011-07-28发行，直到2017-1-17。引入新特性： switch语句块中允许以字符串作为分支条件； 在创建泛型对象时应用类型推断； 在一个语句块中捕获多种异常； 支持动态语言； 支持try-with-resources； 引入Java NIO.2开发包； 数值类型可以用二进制字符串表示，并且可以在字符串表示中添加下划线； 钻石型语法； null值的自动处理。 JavaSE8开发代号为Spider（蜘蛛），于2014年3月18直到如今。引入新特性： Lambda表达式 Stream函数式操作流元素集合 接口新增：默认方法与静态方法 方法引用,与Lambda表达式联合使用 引入重复注解 类型注解 最新的Date/Time API (JSR 310) 新增base64加解密API 数组并行（parallel）操作 JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122）元空间]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[（五）：注解与XML的比较]]></title>
    <url>%2F2017%2F06%2F16%2F%E6%B3%A8%E8%A7%A3Annotation%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在日常开发中，我们大家什么时候感受使用注解最多呢？当然是在各种JavaEE框架的配置中，我们很明显感受到以前很多框架的老版本都是使用的XML文件做配置，而今很多框架的新版本都改成了支持注解配置的方式。那么，注解真的可以用来完全替代XML吗？它们各自的优势是什么？什么时候我们要使用注解配置？什么时候使用XML配置呢？ 综述我们先来看看这两幅图：我们发现两种技术是具有非常大的相似度的。虽然它们的出身、语法完全不同，但是每个阶段的目的是非常的相近。 第一个阶段都是定义可以使用的标记、每个标记的属性，标记的嵌套关系（特别提醒：这表明注解里面的某些属性又是一个注解，从而带来嵌套效果）。说白了就是定义一种存放配置数据的格式； 第二个阶段就是具体的配置阶段，区别在于：XML是一篇独立的文本文件，有它自己的语法格式；注解是直接写在Java文件身上，是属于Java的语法体系； 第三个阶段都是在运行期读取配置信息。XML的解析需要使用到诸如像DOM4J，JDOM等这样的第三方类库，较为麻烦；注解则可以更方便的直接使用Java本身的反射技术进行，相对而言简单一些。 接下来，我们在具体看看这两种技术： XMLXML全称叫做：可扩展标记性语言（eXtensible Markup Language）。它是W3C组织于1998年2月提出的一种SGML（标准通用标记语言）的一个子集。最初的目的是为了能够替代当时的HTML（超文本标记性语言），解决HTML的语法不标准、可扩展性差等问题。后来，XML由于是一种独立的文本格式，而它的语法又能够很丰富的表达各种数据结构，所以又被大量用来作为不同平台之间数据传递的标准格式。它的使用越来越广泛，包括WebService、AJAX等都是基于它的，所以配置文件只是XML的一种用途而已。 注解注解Annotation是Java在JDK1.5中提供的一种新类型。它是在Java代码中的特殊标记，这些标记可以在编译、类加载或运行期被读取，从而执行相应的特殊操作。所以，注解Annotation是Java语言独有的，只能Java用，并且其设计目的就是为了做配置的。 综合比较从以上描述中，我们可以很明显发现Java的注解与XML就不是一个等量级的对手。XML的用途比Java的注解要广泛的多，它不限于语言，只要需要表示数据的地方都可以使用，这是Java注解绝对不可比拟的。所以，Java注解要替代XML是不可能的。那么我们把比较的场景替换成Java代码开发中的配置呢？在这种情况下，Java开发人员或设计人员会更偏向于使用哪一个呢？我们接着聊…… XML配置的优缺点优点 可扩展性强。由于XML是可以自定义标记、属性和嵌套关系的，而且它的定义文件（DTD、Schema）也都是文本文件而已，所以添加或修改都更为方便； 满足开闭原则。XML的配置文件是独立于Java代码之外的，所以如果要修改配置是不需要动到Java代码的； 缺点 解析麻烦，需要第三方类库配合； 配置文件过多后，会导致项目管理、维护等行为变得困难； 在做代码的关联配置的时候麻烦，会让开发人员不断的在Java代码和XML配置文件之间来回切换； 查错困难，由于只是文本文件，所以很多报错只能在运行期间体现，IDE（集成开发环境）无法在编译期排查。 注解配置的优缺点优点 JDK自带反射方式解析，不会引入第三方库； 直接配置在Java源代码中，所以不会引入额外的配置文件，项目管理和维护变得简单了； 无论是定义、配置还是解析都是Java代码，所以不存在配置的时候需要在不同语法格式中切换的问题； IDE支持度高，排查错误方便，提高开发效率； 缺点 任何对配置、对定义的修改都需要改动Java代码，然后重新编译，重新打包应用； 不是通用标准，只能在Java中使用。 总结这个世界没有什么是完美的，同样XML与注解也是这样，各有千秋。仔细通过以上对比，我们能发现XML与注解在配置这个应用场景中互补性是非常高的。XML的缺点就是注解的优点，反之亦然。所以这也是目前在JavaEE的各大框架中XML+Annotation配置流行的原因。把与代码关联度不高，并且改动的可能性大的配置写在XML文件中；专门配置Java代码级别关联度的，以后改动度小的则使用注解Annotation。 最后，本系列到此结束，希望对你有所帮助，感谢🙏🙏！ 系列：注解Annotation全解析（一）：我不是注释注解Annotation全解析（二）：自定义注解的定义注解Annotation全解析（三）：自定义注解的配置使用注解Annotation全解析（四）：自定义注解的运行时解析注解Annotation全解析（五）：注解与XML的比较]]></content>
      <categories>
        <category>JavaSE</category>
        <category>注解Annotation全解析系列</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[（四）：自定义注解的运行时解析]]></title>
    <url>%2F2017%2F06%2F14%2F%E6%B3%A8%E8%A7%A3Annotation%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在本系列的头三个讲解中，我们学习了什么是注解、如何定义注解、以及如何配置注解。那么当做好了这一切，这样的注解在实际中又有什么样的作用呢？这就是我们今天要讨论的：让编写期配置在Java文件的注解影响运行期的效果，即下图的第三步。 回顾我们在前面定义了一个叫LovoAnnotation的注解，并且把它配置在了类Student上，具体代码如下：1234567891011121314import java.lang.annotation.ElementType;import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inheritedpublic @interface LovoAnnotation&#123; public String name(); int age() default 18; int[] scores(); &#125; 12345678@LovoAnnotation(name="zhang3",age=24,scores=&#123;85,67,72&#125;)public class Student&#123; public void study(int times)&#123; for(int i = 0; i &lt; times; i++)&#123; System.out.println("Good Good Study, Day Day Up!"); &#125; &#125;&#125; 那么接下来，我们就以此为例来演示在运行时解析配置在Student类上面的@LovoAnnotation的信息。 运行时解析确认注解的保持力在定义注解的时候有一个元注解叫@Retention。这个注解是专门用来描述自定义注解的保持力。说白了就是这个注解能在存在于源代码、class文件、运行期三个阶段中的哪一个。只有当一个注解，使用了@Retention(RetentionPolicy.RUNTIME)修饰，才表示这个注解能够保持到运行期。也只有这种情况我们才可以在运行期获取到它。所以，首先一定要确认这一点。 反射操作获取注解在运行期探究和使用编译期的内容，当然要用到Java中的开挂技术—反射！1234567891011121314151617181920public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; //获取Student的Class对象 Class stuClass = Class.forName("com.lovo.bean.Student"); if(stuClass.isAnnotationPresent(LovoAnnotation.class))&#123; System.out.println("Student类上配置了LovoAnnotation注解"); LovoAnnotation anno = (LovoAnnotation) stuClass.getAnnotation(LovoAnnotation.class); String name = anno.name(); int age = anno.age(); System.out.println(name + " " + age); &#125;else&#123; System.out.println("Student类上没有配置LovoAnnotation注解"); &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;解释一下： 如果我们要获得的注解是配置在类型上的，那么我们要从Class 对象上获取；如果是配置在属性、构造、普通方法等元素上，那么要从该属性对应的Field对象、该构造对应的Constructor对象、该方法对应的Method对象等反射对象上获取； isAnnotationPresent(注解.class)方法是专门判断是否配置有某个指定的注解对象； getAnnotation(注解.class)方法是获取指定的注解，然后在调用该注解的注解类型元素方法就可以获得配置时的值数据； 反射对象上还有一个方法getAnnotations()，该方法可以获得该对象身上配置的所有的注解。它会返回给我们一个注解数组，需要注意的是该数组的类型是Annotation类型，这个Annotation是一个来自于java.lang.annotation包的接口（我们曾在本系列的第一章介绍过它，记不住就回头去看看）。 1Annotation[] allAnnos = stuClass.getAnnotations(); 如果我们的注解使用了元注解@Inherited修饰的话，那么Student的子类无需配置也会自动具备来自于父类的注解。注意：这个特性仅限于@Target为ElementType.TYPE的注解。 12public class LovoStudent extends Student&#123;&#125; 大家自己测试一下这个结论吧。 总结至此，我们就可以在运行期获得编写java文件时配置的各种注解了。虽然我们写了好几篇博客才搞定，但是其实语法并不复杂，只是我们讲解的比较细致而已。在日常开发中，我们大家什么时候感受使用注解最多呢？当然是在各种JavaEE框架的配置中，我们很明显感受到以前很多框架的老版本都是使用的XML文件做配置，而今很多框架的新版本都改成了支持注解配置的方式。那么，注解真的可以用来完全替代XML吗？请关注本系列的最后一节。系列：注解Annotation全解析（一）：我不是注释注解Annotation全解析（二）：自定义注解的定义注解Annotation全解析（三）：自定义注解的配置使用注解Annotation全解析（四）：自定义注解的运行时解析注解Annotation全解析（五）：注解与XML的比较]]></content>
      <categories>
        <category>JavaSE</category>
        <category>注解Annotation全解析系列</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[（三）：自定义注解的配置使用]]></title>
    <url>%2F2017%2F06%2F12%2F%E6%B3%A8%E8%A7%A3Annotation%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在注解Annotation全解析（二）：自定义注解的定义一文中，我们学会了定义一个自己的注解。1234567891011121314import java.lang.annotation.ElementType;import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inheritedpublic @interface LovoAnnotation&#123; public String name(); int age() default 18; int[] scores(); &#125;那么，定义好了一个注解该如何使用呢？这就是我们接下来要探讨的。 回顾首先，在前面我们说过，在Oracle的官方文档中，注解Annotation的定义是： Annotation 是一种能够被书写到Java源代码中的元数据（metadata：描述数据的数据）形式。类、方法、变量、参数和包都可以使用它来进行描述。Annotation不会对它描述的代码操作有任何的直接影响。 从这个定义中，我们可以看到注解是用来修饰Java源代码中的各种元素的，相当于起到一个配置作用。其次，我们从定义注解的语法可以看到，无论是注解内容中定义的注解类型元素，还是各种元注解的作用，都是用来制定这个自定义注解可以配置什么值，可以配置在哪里，可以在什么阶段读取到这个配置。最后，我们再来看看这幅图：可以看到，定义注解只是做到了第一步，接下来就要配置它，最后能够在运行期读到这个编码期给出的配置数据。接下来我们就来学习如何在另一个类当中配置它 配置Annotation我们就利用这里定义的LovoAnnotation来进行学习吧。 首先，我们要书写一个将要使用注解修饰的Java类由于我们没有具体的使用场景，只能就语法进行讨论，所以简单定义一个Java类如下：1234567public class Student&#123; public void study(int times)&#123; for(int i = 0; i &lt; times; i++)&#123; System.out.println("Good Good Study, Day Day Up!"); &#125; &#125;&#125; 接下来，我们就可以在这个类身上使用我们的LovoAnnotation我们先分析一下LovoAnnotation的定义： 注解名叫做LovoAnnotation，因此我们要使用的标记形式应该是：@LovoAnnotation; LovoAnnotation的@Target是定义为Element.TYPE的，那么它书写的位置应该在类型定义的上方，即：public class Student之上； 由于我们在LovoAnnotation中定义的有注解类型元素，而且有些元素是没有默认值的，这要求我们在使用的时候必须标记名后面打上()，并且在()内以“元素名=元素值“的形式挨个填上所有没有默认值的注解类型元素（有默认值的也可以填上重新赋值），中间用“,”号分割； 所以我们最终书写的正确形式如下：12345678@LovoAnnotation(name="zhang3",age=24,scores=&#123;85,67,72&#125;)public class Student&#123; public void study(int times)&#123; for(int i = 0; i &lt; times; i++)&#123; System.out.println("Good Good Study, Day Day Up!"); &#125; &#125;&#125;特殊语法：1、如果注解本身没有定义注解类型元素，那么在使用注解的时候可以省略()，直接写为：@注解名，它和标准语法@注解名()等效！123@Target(&#123;ElementType.TYPE&#125;)public @interface SpecialAnnotation&#123;&#125;1234567//等效于@SpecailAnnotation()@SpecailAnnotationpublic class SomeBean&#123; //属性 //构造 //行为&#125;2、如果注解本身在其内部只定义了一个注解类型元素，并且其命名为value，那么在使用注解的时候可以直接写为：@注解名(注解值)，它和标准写法：@注解名(value=注解值)等效！1234@Target(&#123;ElementType.TYPE&#125;)public @interface SpecialAnnotation&#123; float value();&#125;1234567//等效于@SpecailAnnotation(value=2.26f)@SpecailAnnotation(2.26f)public class SomeBean&#123; //属性 //构造 //行为&#125;3、如果注解中某个注解类型元素是一个数组类型，在使用时又出现只需要填入一个值的情况，那么在使用注解的时候可以直接写为：@注解名（类型名=类型值），它和标准写法：@注解名(类型名={类型值})等效！1234@Target(&#123;ElementType.TYPE&#125;)public @interface SpecialAnnotation&#123; String[] addresses();&#125;1234567//等效于@SpecailAnnotation(addresses=&#123;"NYC"&#125;)@SpecailAnnotation(addresses="NYC")public class SomeBean&#123; //属性 //构造 //行为&#125;4、如果一个注解的@Target是定义为Element.PARAMETER，那么这个注解是配置在方法的形参前面的，其语法形式如下：1234@Target(&#123;ElementType.PARAMETER&#125;)public @interface SpecialAnnotation&#123; boolean flag();&#125;12345678public class SomeBean&#123; //属性 //构造 //行为 public void test(@SpecailAnnotation(flag=true) int num)&#123; //方法实现部分 &#125;&#125;5、如果一个注解的@Target是定义为Element.PACKAGE，那么这个注解是配置在package-info.java中的，而不能直接在某个类的package代码上面配置。 最后，我们生成DOC文档由于我们在定义LovoAnnotation注解的时候，使用了元注解@Documented，所以我们可以在生成的Doc文档中找到Student这个类的描述，并在描述中看到它身上配置的注解信息。 总结在我们的日常的使用中，主要执行的操作就是把定义好的注解配置在我们自己写的Java代码上。所以注解的配置语法几乎是我们最频繁的操作。如果我们掌握了本次讲解的内容，就完全不用针对每一个注解去死记硬背它的配置方式，而是可以方便的通过该注解的定义就能推出它的配置语法，也便于我们使用JavaDoc文档去查询学习新的注解。好吧，在掌握了本次的内容后，我们就可以继续学习如何在运行期得到我们在编写代码时配置的注解内容，请期待本系列的下一节。 系列：注解Annotation全解析（一）：我不是注释注解Annotation全解析（二）：自定义注解的定义注解Annotation全解析（三）：自定义注解的配置使用注解Annotation全解析（四）：自定义注解的运行时解析注解Annotation全解析（五）：注解与XML的比较]]></content>
      <categories>
        <category>JavaSE</category>
        <category>注解Annotation全解析系列</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[（二）：自定义注解的定义]]></title>
    <url>%2F2017%2F06%2F10%2F%E6%B3%A8%E8%A7%A3Annotation%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在注解Annotation全解析（一）：我不是注释一文中，我们对于注解有了一个基本的认识：注解其实就是给我们代码中的一些关键节点（包、类、方法、参数、属性等）打上一些标记，然后在编译期或运行期通过判断这些标记来执行一些指定操作。那么通过这个流程我们可以分析出注解的使用结构是：要想完全学会注解，光靠用别人定义的注解是不够的，所以我们要学会自己定义注解。另外，请在学习的下面内容的时候，打开你的Eclipse跟着内容进行编码。 基本定义语法注解类型的声明部分注解（Annotation）在Java中是一种与类、接口、枚举等同等地位的标示类型，所以它的基本定义语法与上面这几个都是一致的，只是所使用的关键字有所不同。123//定义一个公共的名为LovoAnnotation的注解public @interface LovoAnnotation&#123; &#125;它使用的定义关键字是：@interface。这无疑表明了注解和接口是有关系的。实际上，注解其本质就是一种特殊的接口。在底层实现上，所有定义的注解（Annotation）都会自动继承java.lang.annotion.Annotation接口。但请注意，注解的声明只能使用@interface，如果自以为是的写成：123import java.lang.annotation.Annotation;public interface LovoAnnotation extends Annotation&#123;&#125;那么不好意思，LovoAnnotation不会被认为是注解类型，只会被当成一个普通的接口。 注解类型的实现部分根据我们书写类、接口等自定义类型的经验，在这些类型的实现部分无非是书写属性、构造或方法这些内容。但是，注解（Annotation）在实现部分允许书写的内容与之前我们的经验完全不同。注解（Annotation）在实现部分只能定义一个东西：注解类型元素（annotation type element）。我们来看看它的语法：12345public @interface LovoAnnotation&#123; public String name(); int age(); int[] array(); &#125;这个时候有些反应快的同学肯定会想：咦？这不就是接口里面默认定义抽象方法的语法吗？不要着急，我再写一个给你看：12345public @interface LovoAnnotation&#123; public String name(); int age() default 18; int[] scores(); &#125;还是抽象方法吗？打脸了吧！注解里面定义的是：注解类型元素！注解类型元素！注解类型元素！重要的事情说三遍！ 该元素的访问修饰符只能是public，不写也默认为public； 该元素的类型只能是基本数据类型、String、Class、注解类型（体现了注解嵌套的效果）、枚举类型以及上面这几种的一维数组； 该元素的名字应该一般都是名词形式，如果一个注解中只有一个类型元素，请把名字起成value（后面使用会带来便利操作）； ()不是定义方法参数列表的地方，也不能在括号中定义任何参数，就是一个特殊语法； default代表默认值，值必须和第2点定义的类型保持一致； 如果没有默认值，代表后面使用时必须给该类型元素赋值； 不得不说，注解元素类型的语法非常奇怪，即有属性的特征（可以赋值），又有方法的特征（打上了一对圆括号）。但是这么设计是有道理的，我们在后面的系列文章中可以看到：注解（Annotation）在定义好了以后，使用的时候操作元素类型像在操作属性，解析的时候操作元素类型像在操作方法。 常用的元注解一个最最基本的注解定义就只包括了上面的两部分内容：1、注解的名字；2、注解包含的类型元素。但是，我们在使用JDK自带注解的时候发现，有些注解只能写在方法上面（比如@Override）；有些却可以写在类的上面（比如@Deprecated）。当然除此以外还有很多细节性的定义，那么这些定义该如何做呢？接下来就该元注解出场了！元注解：专门修饰注解的注解。它们都是为了更好的设计自定义注解的细节而专门设计的。我们为大家一个个来做介绍。 @Target@Target注解，是专门用来限定某个自定义注解能够被应用到哪些Java元素上面的。它使用一个枚举类型ElementType定义了如下几个选择： 枚举值 注解能够被应用的地方 ElementType.ANNOTATION_TYPE 注解类型的声明 ElementType.CONSTRUCTOR 构造方法的声明 ElementType.FIELD 属性的声明 ElementType.LOCAL_VARIABLE 局部变量的声明 ElementType.METHOD 方法的声明 ElementType.PACKAGE 包的声明 ElementType.PARAMETER 方法参数的声明 ElementType.TYPE 类、接口以及枚举的声明 123456789import java.lang.annotation.ElementType;import java.lang.annotation.Target;//LovoAnnotation被限定在只能写在属性的声明上或方法的声明上@Target(&#123;ElementType.FIELD,ElementType.METHOD&#125;)public @interface LovoAnnotation&#123; public String name(); int age() default 18; int[] scores(); &#125; @Retention@Retention注解，被翻译成保持力或持久力。它是用来限定某个自定义注解的生命力。注解的生命周期有三个阶段：仅存在java源文件是一个阶段；被编译到class文件是一个阶段；运行期被加载到Class对象中是第三个阶段。@Retention同样使用一个枚举类型RetentionPolicy定义了这三个选择： 枚举值 对应的生命力 RetentionPolicy.SOURCE 仅在Java源文件中 RetentionPolicy.CLASS 被编译到class文件中 RetentionPolicy.RUNTIME 运行期放到Class对象中 我们再详解一下： 如果一个注解被限定在Java源文件中，那么这个注解即不会参与编 译也不会在运行期起任何作用，这个注解就和一个注释是一样的效果，只能被阅读Java文件的人看到； 如果一个注解被编译到Class文件中，那么编译器可以在编译时根据注解做一些处理动作，但是运行时JVM（Java虚拟机）会忽略它，我们在运行期也不能读取到； 如果一个注解被定义在RetentionPolicy.RUNTIME，那么这个注解可以在运行期的加载阶段被加载到Class对象中。那么在程序运行阶段，我们可以通过反射得到这个注解，并通过判断是否有这个注解或这个注解中属性的值，从而执行不同的程序代码段。我们实际开发中的自定义注解几乎都是使用的RetentionPolicy.RUNTIME； 在默认的情况下，自定义注解是使用的RetentionPolicy.CLASS。 123456789import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;//LovoAnnotation的生命力被保持到运行阶段@Retention(RetentionPolicy.RUNTIME)public @interface LovoAnnotation&#123; public String name(); int age() default 18; int[] scores(); &#125; @Documented@Documented注解，是被用来指定自定义注解是否能随着被定义的java文件生成到JavaDoc文档当中。 @Inherited@Inherited注解，是指定某个自定义注解如果写在了父类的声明部分，那么子类的声明部分也能自动拥有该注解。@Inherited注解只对那些@Target被定义为ElementType.TYPE的自定义注解起作用。 一个完整的自定义Annotation示例在学习了上面的各种定义注解的语法后，我们就可以根据我们的实际需要定义我们自己的自定义注解了。下面，我们就来定义一个：1234567891011121314import java.lang.annotation.ElementType;import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inheritedpublic @interface LovoAnnotation&#123; public String name(); int age() default 18; int[] scores(); &#125; 当我们定义好了这个注解，那么接下来的事情就是如何使用它了。请关注我们关于注解的下一个章节。 系列：注解Annotation全解析（一）：我不是注释注解Annotation全解析（二）：自定义注解的定义注解Annotation全解析（三）：自定义注解的配置使用注解Annotation全解析（四）：自定义注解的运行时解析注解Annotation全解析（五）：注解与XML的比较]]></content>
      <categories>
        <category>JavaSE</category>
        <category>注解Annotation全解析系列</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[（一）：我不是注释]]></title>
    <url>%2F2017%2F06%2F08%2F%E6%B3%A8%E8%A7%A3Annotation%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我们在IDE（集成开发环境，比如：Eclipse）工具中开发程序时，经常会使用自动代码生成的方式完成一些重写操作。这个时候，我们常常发现工具会在重写方法上面会自动出现一行奇怪的代码：@Override。1234@Overridepublic String toString()&#123; return "返回对象的字符串描述";&#125;我们试着保留它，或是删掉它，结果发现这个东西对我们重写的语法似乎并没有什么影响。久而久之，大家也就习惯了它的存在，并忽略了它，甚至误认为它不是Java代码而是Eclipse自己提供的一个东东，不关Java的事情。今天，我们来认识认识这个语法，它叫做：注解———Annotation。 Annotation的概念我们先明确一点，Annotation（注解）是一个确定的Java语法。虽然它出现的时间较晚，在JDK1.5才被提出来，但确实是Java的亲儿子。我们来看看官方对它的描述： An annotation is a form of metadata, that can be added to Java source code. Classes, methods, variables, parameters and packages may be annotated. Annotations have no direct effect on the operation of the code they annotate. 翻译如下： Annotation 是一种能够被书写到Java源代码中的元数据（metadata：描述数据的数据）形式。类、方法、变量、参数和包都可以使用它来进行描述。Annotation不会对它描述的代码操作有任何的直接影响。 通过对上文的中文仔细分析，我们可以得到如下几个重要结论：1、Annotation是一种元数据形式。也就是说它其实是属于Java中的一种数据类型，其地位和类、接口、数组、枚举这些都是一样的；2、Annotation是书写在Java代码中的，但是其书写的位置被固定为类、方法、变量、参数和包的申明部分（原文中be annotated 直译为 附注）；3、Annotation不会对所描述的代码有直接影响。这句话是最让初学者困惑的，因为这个时候另一个概念在脑袋里面浮现出来了，它就是注释。 Annotation不是注释注释是作为程序员的我们非常熟悉的一个概念。它是对代码的解释和说明，其目的是让阅读代码的人能够更加轻松地了解代码。编写程序时，写程序的人给一个语句、程序段、函数等作出解释或提示，能提高程序代码的可读性。注释，只存在于Java源代码当中，由于对于编译和运行没有任何作用，它甚至不会被编译到class文件里面。因为它就是给人看的，编译器和JVM都不需要知道它。但Annotation也是如此吗？我们还是以@Override为例：第一种情况：假如我们没有书写这个Annotation，然后进行错误的重写：第二种情况：假如我们书写了Annotation，然后进行错误的重写：这时我们马上发现：第一种方式编译器根本就不给我们报错，它会默认为我们添加了一个全新的方法，而不是在进行重写；第二种方式则会立马编译失败，并且明确告诉我们这不是一个正确的重写。这说明什么？ 这说明，@Override这个Annotation可不是仅仅给人读的，它还影响到了编译器，编译器也读到了它，并且做出了相应的操作！就凭这一点，就可以断言Annotation不是注释。怪不得给它翻译了一个独特的中文名：注解，以示区分。我们再来看看官方对它的使用范围的描述： Annotations have a number of uses, among them:Information for the compiler — Annotations canbe used by the compiler to detect errors orsuppress warnings.Compile-time and deployment-time processing —Software tools can process annotation informationto generate code, XML files, and so forth.Runtime processing — Some annotations areavailable to be examined at runtime. 翻译如下： 注解有非常多的用途，包括如下：为编译器提供信息 —— 注解可用于让编译器检测错误或抑制警告。编译时和部署时处理 —— 软件工具可以处理注解信息从而生成代码，XML文件等等。运行时处理 —— 一些注解可以在运行时被检查到。 厉害了，我的哥！我们可以清楚的看到，注解可不是仅仅给程序员看的，它还可以在编译期和运行期起作用，影响到编译器的编译动作或是最终的运行效果。这个时候，你还认为它和注释是一回事情吗？那么，这么厉害的玩意儿，咋用呢？ JDK自带的常用Annotation我们先学一下JDK中最常用的三个Annotation。它们分别是：@Override、@Deprecated和@SuppressWarnings。 @Override这个注解我们在上面已经大量使用过了，平时也见得很多。它是专门用来限定重写父类方法。对于子类中被@Override修饰的方法，如果存在对应的被重写的父类方法，则编译通过；如果不存在，则编译报错。@Override只能作用于方法，不能作用于其他程序元素。 @Deprecated用于表示某个程序元素（类、方法等）已过时。如果使用被@Deprecated修饰的类或方法等，编译器会发出警告。需要注意的是：过时的类或方法并不代表错误，只是有了更好的新的替代而不再推荐使用了。 @SuppressWarnings抑制编译器警告。指示被@SuppressWarnings修饰的程序元素（以及该程序元素中的所有子元素，例如类以及该类中的方法…..）取消显示的编译器警告。比如：使用前使用后可以很明显的发现，Eclipse中黄色的警告标记不见了。其中“unused”是抑制了lst变量申明后没有被使用的警告；“rawtypes”是抑制了没有使用泛型的警告。常见的能够抑制的警告及其关键字在下表中： 关键字 被抑制的警告类型 all 抑制所有警告 deprecation 抑制使用了过时的类或方法的警告 fallthrough 抑制switch块中没有break语句的警告 finally 抑制finally块不能正常完成的警告 rawtypes 抑制没有使用泛型的警告 serial 抑制可序列化类没有使用序列化ID的警告 unchecked 抑制未检查操作的警告 unused 抑制变量或方法申明定义后未使用的警告 总结Annotation(注解)相当于一种标记，当我们在程序代码中加入注解就相当于为程序打上了某种标记。编译器、开发工具和其他程序可以通过了解类以及类中的各种元素上有无何种标记，从而执行相应的动作。注解标记可以加在包、类，属性、方法，方法的参数以及局部变量上。 系列：注解Annotation全解析（一）：我不是注释注解Annotation全解析（二）：自定义注解的定义注解Annotation全解析（三）：自定义注解的配置使用注解Annotation全解析（四）：自定义注解的运行时解析注解Annotation全解析（五）：注解与XML的比较]]></content>
      <categories>
        <category>JavaSE</category>
        <category>注解Annotation全解析系列</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[向上转型，向下转型，还在头疼？]]></title>
    <url>%2F2017%2F05%2F18%2F%E5%90%91%E4%B8%8A%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在学习Java编程中，最头疼事情之一就是数据类型转换。有时候它在不经意之间就完成了（自动类型转换），有时候却又要求程序员必须手动指定（强制类型转换）。基本数据类型，转换规则还可以通过类型本身空间大小和精度分析明白，而且最多就是丢失精度但运行起来至少是不会报错。可是面对引用数据类型，这个“坑”就大了：有自动转的，有强制转的，居然还有强制都转不了的；自动转了的却把对象身上的方法丢了看不见；强制转的编译过了运行却可能报异常。 一口老血，有木有？更要命的是，这个转型还相当的重要，Java中的动态多态还非它不可了。你说要命不要命？没关系，今天就让我们花点时间聊聊它，搞定它！ 对象不是你想转，想转就能转先人说：知己知彼，百战不殆。我们先来认知一下引用数据类型的一些基本概念，以下所有分析都基于两个方面进行：Java语法 和 面向对象场景。在普通情况下，我们会书写这样的代码：1234Dog snoopy = new Dog();snoopy.play();//调用Dog的玩耍行为snoopy.sitDown();//调用Dog的坐下行为snoopy.shakeHands();//调用Dog的握手行为我们看到在这个语法当中，赋值符号左右两边的数据类型是相同。赋值号左边是Dog类的引用snoopy变量，指向了右边new出来的Dog类对象。这个语法在对应的日常场景中是非常形象的。我们用snoopy称呼一个狗对象，并且确定一定以及肯定snoopy就是一个狗东西。然后我们就可以大喊：snoopy来玩游戏啦，snoopy坐下，snoopy握手。你看，多自然。但是，如果我们写出下面的代码：12Dog snoopy = new Cat();snoopy.sitDown();赋值符号左右两边的数据类型是不同。赋值号左边是Dog类的引用snoopy变量，指向了右边new出来的Cat类对象。编译后，你就发现这句代码根本通不过。为什么？因为这个语法是荒谬的。snoopy明明是狗的代名词，结果你却让它指向了一只猫？还想让它执行狗才有的指令？铲屎的，你是不是不想活了？这个时候有同学想到了，那就强转。12Dog snoopy = （Dog）new Cat();snoopy.sitDown();这就更令人发指了吧，你要怎么做才能强行让一只猫咪对象变成一只汪对象？上帝也疯狂了……你觉得Java会让允许你干这种完全匪夷所思不合常理的事情吗？所以，这句代码的下场也只有一个，那就是编译不通过。因此，我们得到了第一个结论：在Java当中不是任意引用数据类型之间都能进行转换！那么，哪些引用类型之间可以呢？ 向上转型—自动转换，没问题我们分别定义两个类：一个叫做Pet（宠物）；一个叫做Dog，并且让Dog继承于Pet。12345public class Pet&#123; public void play()&#123; System.out.println("玩游戏"); &#125;&#125;12345public class Dog extends Pet&#123; public void sitDown()&#123; System.out.println("坐下"); &#125;&#125;那么，我们在需要调用处写下这个代码会发生什么呢？1Pet myBaby = new Dog();你会发现虽然在赋值符号两边的数据类型不一致，但是这句代码无论是编译还是运行都完全没有问题，也就是说Java中父类的引用指向子类对象是自动成功的。 这是为啥呢？其实无论是从语法上还是从场景分析上，我们会发现这是非常自然的，本身就应该自动成功。继承关系本就是一种is a关系，即所谓的“是一个“，所以Dog对象是一个Pet类型的呀（狗就是一种宠物嘛～～），这完全没有问题。在继承关系上，我们设计时通常在继承树上把父类画在上，子类在下，由于这种转型是沿着继承树往上走，所以我们把它称为–向上转型。但是，12myBaby.play();//编译通过myBaby.sitDown();//编译失败这又是为啥呢？因为myBaby是一个Pet类型的引用，所以是站在宠物的角度去看待汪对象。虽然对象还是狗狗，但是只能看到来自于父类宠物定义的play方法了。所以父类引用指向子类对象，只能调用到来自父类的属性／行为那如何调用到sitDown方法呢？答案很简单：换成狗的角度去看待这个汪星人。 向下转型—强制转换，有风险1234Pet myBaby = new Dog();myBaby.play();Dog snoopy = (Dog)myBaby;snoopy.sitDown(); 这段代码无论编译还是运行都不会有任何问题。我们先使用Pet类型的myBaby指向了狗对象，然后再换成Dog类型的snoopy去指向同一个狗对象。前者由于是父类型所以只能看到定义在父类的方法，后者是子类型，当然就可以看到狗对象身上的特有行为了。这种转型是从父类引用转为子类引用，从继承树的角度说就是向下转型。那为什么在把myBaby赋给snoopy的时候要使用强转语法呢？我们假设下面这种情况：如果Pet类还有一个子类叫做Cat类。12345public class Cat extends Pet&#123; public void climbTree()&#123; System.out.println("爬树"); &#125;&#125;然后书写代码：12345public class Master&#123; public void playWithPet(Pet myBaby)&#123; //操作代码 &#125;&#125;那么，你告诉我传进来的myBaby到底是Dog对象呢？还是Cat对象？或者是Pet对象？由于父类引用可以指向子类对象，所以上面几种情况皆有可能了。所以我们如果想转型Dog类，就必须强制告诉Java，myBaby确实是一个Dog类型的对象。因此我们需要在注释部分书写：1Dog snoopy = (Dog)myBaby;不过，就算你这么书写也只能保证编译通过，这个代码运行起来还是有可能失败，这就是所谓的强转风险性吧。如果你赋给myBaby的是🐶对象，当然没有问题；但假如赋的是🐱对象呢？这是不是相当于我们又从狗的角度去看待一个猫对象了？如何让一只狗变成一只猫，这又是一个荒谬的事情了。所以，如果向下转型想要编译和运行都成功，必须使用强制转型语法，还必须要求运行起来父类引用确实指向该子类的对象。所以，为了降低这种风险性，我们可以使用Java中的instance运算符，在强转前进行一次判断。所以最终代码是：123456789public class Master&#123; public void playWithPet(Pet myBaby)&#123; myBaby.play(); if(myBaby instanceof Dog)&#123; Dog snoopy = (Dog)myBaby; snoopy.sitDown(); &#125; &#125;&#125; 结论 在引用数据类型中，只有有继承关系的类型才能进行类型转换； 类型转换只是转换看待对象的引用的类型，对象本身没有也不可能参与转换； 父类引用可以自动指向子类对象，但只能访问和调用到来自于父类的属性和行为； . 子类的引用不能指向父类或其它子类对象，就算强转也会导致运行失败并抛出ClassCastException； . 把父类引用赋给子类引用，语法上必须使用强制类型转换，要想运行也成功还必须保证父类引用指向的对象一定是该子类对象（最好使用instance判断后，再强转）。]]></content>
      <categories>
        <category>JavaSE</category>
        <category>Java面向对象语法</category>
      </categories>
  </entry>
</search>